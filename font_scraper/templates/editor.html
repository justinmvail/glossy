<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Edit {{ char }} - {{ font.name }}</title>
<style>
  * { box-sizing: border-box; }
  body { font-family: system-ui, sans-serif; margin: 0; padding: 15px; background: #1a1a2e; color: #eee; }
  a { color: #7eb8f7; text-decoration: none; }
  a:hover { text-decoration: underline; }
  .nav { margin-bottom: 10px; font-size: 14px; }
  .header { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
  .header h1 { margin: 0; font-size: 22px; }
  .header .charLabel { font-size: 28px; background: #222; padding: 2px 14px; border-radius: 4px; }

  .main { display: flex; gap: 20px; }
  .canvas-wrap { position: relative; }
  canvas { background: #fff; border-radius: 4px; cursor: crosshair; }
  .sidebar { min-width: 220px; }

  .toolbar { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
  .toolbar button {
    padding: 5px 10px; border: 1px solid #444; background: #222; color: #eee;
    border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;
  }
  .toolbar button:hover { background: #333; }
  .toolbar button.active { background: #335; border-color: #7eb8f7; }
  .toolbar button.save { background: #254; border-color: #4a8; }
  .toolbar button.save:hover { background: #365; }
  .toolbar button.process { background: #352; border-color: #a84; }
  .toolbar button.process:hover { background: #463; }

  .section-label { font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.5px;
    margin-top: 8px; margin-bottom: 4px; }

  .stroke-list { font-size: 13px; max-height: 250px; overflow-y: auto; }
  .stroke-item {
    padding: 4px 8px; border-radius: 3px; margin-bottom: 2px;
    cursor: pointer; display: flex; align-items: center; gap: 6px;
  }
  .stroke-item:hover { background: #2a2a3e; }
  .stroke-item.selected { background: #2a2a4e; }
  .stroke-color { width: 12px; height: 12px; border-radius: 2px; display: inline-block; flex-shrink: 0; }
  .stroke-delete { margin-left: auto; color: #a55; cursor: pointer; font-size: 16px; }
  .stroke-delete:hover { color: #f66; }

  .status { font-size: 12px; color: #888; margin-top: 10px; }
  .status.saved { color: #4a8; }

  /* Streaming indicator banner */
  .stream-banner {
    display: none;
    background: #1a2a1a;
    border: 1px solid #3a6a3a;
    border-radius: 6px;
    padding: 8px 12px;
    margin-top: 10px;
    font-size: 12px;
    color: #ccc;
  }
  .stream-banner.active { display: block; }
  .stream-banner .stream-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
  }
  .stream-banner .stream-spinner {
    width: 12px; height: 12px;
    border: 2px solid #3a6a3a;
    border-top-color: #6c6;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .stream-banner .stream-label {
    font-weight: bold;
    color: #6c6;
  }
  .stream-banner .stream-elapsed {
    margin-left: auto;
    color: #999;
    font-variant-numeric: tabular-nums;
  }
  .stream-banner .stream-details {
    display: flex;
    gap: 16px;
    color: #aaa;
    font-size: 11px;
  }
  .stream-banner .stream-details span { white-space: nowrap; }
  .stream-banner .stream-details .val { color: #ddd; }
  .stream-banner .stream-stop {
    margin-left: auto;
    background: #5a2a2a;
    color: #ddd;
    border: 1px solid #744;
    border-radius: 3px;
    padding: 1px 8px;
    cursor: pointer;
    font-size: 11px;
  }
  .stream-banner .stream-stop:hover { background: #733; }
  .stream-banner.done { border-color: #4a8a4a; }
  .stream-banner.done .stream-spinner { display: none; }
  .stream-banner.done .stream-label { color: #4a8; }

  .help { font-size: 11px; color: #555; margin-top: 12px; line-height: 1.7; }
  .help kbd {
    background: #333; padding: 1px 4px; border-radius: 3px; border: 1px solid #444;
    font-family: inherit; font-size: 10px; min-width: 16px; display: inline-block; text-align: center;
  }
  .help .row { display: flex; gap: 6px; }
  .help .key { min-width: 70px; flex-shrink: 0; }
</style>
</head>
<body>
<div class="nav">
  <a href="/">&larr; Fonts</a> &middot; <a href="/font/{{ font.id }}">{{ font.name }}</a>
</div>
<div class="header">
  <h1>{{ font.name }}</h1>
  <span class="charLabel">{{ char }}</span>
</div>
<div class="main">
  <div class="canvas-wrap">
    <canvas id="canvas" width="768" height="768"></canvas>
    <div id="playerPanel" style="display:none; margin-top:6px; width:768px;">
      <div style="display:flex; gap:6px; align-items:center; margin-bottom:4px;">
        <select id="sessionSelect" onchange="selectSession()" style="background:#222; color:#eee; border:1px solid #444; border-radius:3px; font-size:12px; padding:2px 4px; min-width:140px;"></select>
        <button onclick="playFirst()" style="padding:3px 6px; background:#222; color:#eee; border:1px solid #444; border-radius:3px; cursor:pointer; font-size:11px;">|&lt;</button>
        <button onclick="playStep(-1)" style="padding:3px 6px; background:#222; color:#eee; border:1px solid #444; border-radius:3px; cursor:pointer; font-size:11px;">&lt;</button>
        <button id="btnPlayPause" onclick="togglePlay()" style="padding:3px 10px; background:#254; color:#eee; border:1px solid #4a8; border-radius:3px; cursor:pointer; font-size:11px;">Play</button>
        <button onclick="playStep(1)" style="padding:3px 6px; background:#222; color:#eee; border:1px solid #444; border-radius:3px; cursor:pointer; font-size:11px;">&gt;</button>
        <button onclick="playLast()" style="padding:3px 6px; background:#222; color:#eee; border:1px solid #444; border-radius:3px; cursor:pointer; font-size:11px;">&gt;|</button>
        <select id="speedSelect" onchange="setPlaySpeed(+this.value)" style="background:#222; color:#eee; border:1px solid #444; border-radius:3px; font-size:11px; padding:2px;">
          <option value="500">0.5x</option>
          <option value="200" selected>1x</option>
          <option value="100">2x</option>
          <option value="50">4x</option>
        </select>
        <span id="frameInfo" style="font-size:11px; color:#888; white-space:nowrap; margin-left:auto;"></span>
      </div>
      <input id="timeline" type="range" min="0" max="0" value="0" oninput="seekFrame(+this.value)" style="width:100%;">
    </div>
  </div>
  <div class="sidebar">
    <div class="section-label">Mode</div>
    <div class="toolbar">
      <button id="btnSelect" class="active" onclick="setMode('select')"><kbd>V</kbd> Select</button>
      <button id="btnAddStroke" onclick="setMode('addStroke')"><kbd>A</kbd> + Stroke</button>
      <button id="btnDeleteStroke" onclick="setMode('deleteStroke')"><kbd>X</kbd> - Stroke</button>
      <button id="btnDetectMarkers" class="process" onclick="detectMarkers()"><kbd>4</kbd> Detect V/T</button>
      <button id="btnAddVertex" onclick="setMode('addVertex')"><kbd>1</kbd> + Vertex</button>
      <button id="btnAddTerm" onclick="setMode('addTermination')"><kbd>2</kbd> + Termination</button>
      <button id="btnClearMarkers" onclick="clearMarkers()"><kbd>3</kbd> Clear Markers</button>
    </div>
    <div class="section-label">Edit</div>
    <div class="toolbar">
      <button id="btnDeletePoint" onclick="deleteSelectedPoint()"><kbd>Del</kbd> Del Point</button>
      <button id="btnSplit" onclick="splitStroke()"><kbd>B</kbd> Split</button>
      <button id="btnVertex" onclick="toggleVertex()"><kbd>T</kbd> Vertex</button>
      <button id="btnJoin" onclick="startJoin()"><kbd>J</kbd> Join</button>
      <button id="btnUndo" onclick="undo()"><kbd>Z</kbd> Undo</button>
      <button id="btnReload" onclick="reloadChar()"><kbd>R</kbd> Revert</button>
      <button id="btnClearPage" onclick="clearPage()">Clear Page</button>
    </div>
    <div class="section-label">Process</div>
    <div class="toolbar">
      <button id="btnDedup" class="process" onclick="runDedup()"><kbd>D</kbd> Dedup</button>
      <button id="btnConnect" class="process" onclick="runConnect()"><kbd>C</kbd> Connect</button>
      <button id="btnSmooth" class="process" onclick="runSmooth()"><kbd>G</kbd> Smooth</button>
      <button id="btnSnap" class="process" onclick="runSnap()"><kbd>N</kbd> Snap to Outline</button>
      <button id="btnCenterBorders" class="process" onclick="runCenterBorders()"><kbd>M</kbd> Center in Stroke</button>
      <button id="btnCenter" class="process" onclick="runCenter()"><kbd>O</kbd> Center BBox</button>
      <button id="btnResample" class="process" onclick="runResample()"><kbd>E</kbd> Resample</button>
      <button id="btnScaleUp" class="process" onclick="runScale(1.03)"><kbd>+</kbd> Scale Up</button>
      <button id="btnScaleDn" class="process" onclick="runScale(1/1.03)"><kbd>-</kbd> Scale Down</button>
      <button id="btnSkeleton" class="process" onclick="runSkeleton()"><kbd>K</kbd> Skeleton</button>
      <button id="btnSkeletonFull" class="process" onclick="runSkeletonFull()"><kbd>F</kbd> Skel+Resample</button>
      <button id="btnOptLive" class="process" onclick="runOptimizeLive()" style="background:#2a5a2a"><kbd>O</kbd> Optimize Live</button>
      <button id="btnDiffVG" class="process" onclick="runDiffVG()" style="background:#2a4a5a"><kbd>Y</kbd> DiffVG Refine</button>
      <button id="btnClearCache" class="process" onclick="clearShapeCache()" style="background:#5a2a2a">Clear Cache</button>
      <button id="btnAutoJoin" class="process" onclick="runAutoJoin()"><kbd>W</kbd> Auto-Join</button>
      <button id="btnReduce" class="process" onclick="runReduce()"><kbd>Q</kbd> Reduce</button>
    </div>
    <div class="section-label">Navigate</div>
    <div class="toolbar">
      <button id="prevChar" onclick="navigateChar(-1)"><kbd>[</kbd> Prev</button>
      <button id="nextChar" onclick="navigateChar(1)"><kbd>]</kbd> Next</button>
      <button id="btnSave" class="save" onclick="save()"><kbd>S</kbd> Save</button>
    </div>

    <div class="section-label">Strokes</div>
    <div id="strokeList" class="stroke-list"></div>
    <div id="status" class="status"></div>
    <div id="streamBanner" class="stream-banner">
      <div class="stream-header">
        <div class="stream-spinner"></div>
        <span class="stream-label" id="streamLabel">Streaming</span>
        <span class="stream-elapsed" id="streamElapsed">0s</span>
      </div>
      <div class="stream-details">
        <span>Phase: <span class="val" id="streamPhase">--</span></span>
        <span>Score: <span class="val" id="streamScore">--</span></span>
        <span>Frame: <span class="val" id="streamFrame">--</span></span>
        <button class="stream-stop" id="streamStop" onclick="stopStream()">Stop</button>
      </div>
    </div>

    <div class="help">
      <strong>All Shortcuts</strong>
      <div class="row"><span class="key"><kbd>V</kbd></span> Select mode</div>
      <div class="row"><span class="key"><kbd>A</kbd></span> Add stroke mode</div>
      <div class="row"><span class="key"><kbd>X</kbd></span> Delete stroke mode</div>
      <div class="row"><span class="key"><kbd>&larr;</kbd> <kbd>&rarr;</kbd></span> Prev / next point</div>
      <div class="row"><span class="key"><kbd>Del</kbd></span> Delete point(s)</div>
      <div class="row"><span class="key"><kbd>T</kbd></span> Toggle vertex (locked)</div>
      <div class="row"><span class="key"><kbd>B</kbd></span> Split stroke at point</div>
      <div class="row"><span class="key"><kbd>J</kbd></span> Join two strokes</div>
      <div class="row"><span class="key"><kbd>Shift</kbd>+click</span> Select range</div>
      <div class="row"><span class="key">Drag empty</span> Marquee select</div>
      <div class="row"><span class="key"><kbd>Ctrl</kbd>+<kbd>Z</kbd></span> Undo</div>
      <div class="row"><span class="key"><kbd>R</kbd></span> Revert (reload from DB)</div>
      <div class="row"><span class="key"><kbd>D</kbd></span> Dedup overlapping strokes</div>
      <div class="row"><span class="key"><kbd>C</kbd></span> Connect strokes</div>
      <div class="row"><span class="key"><kbd>N</kbd></span> Snap to outline</div>
      <div class="row"><span class="key"><kbd>M</kbd></span> Center in stroke width</div>
      <div class="row"><span class="key"><kbd>O</kbd></span> Center bbox on glyph</div>
      <div class="row"><span class="key"><kbd>E</kbd></span> Resample (adaptive)</div>
      <div class="row"><span class="key"><kbd>G</kbd></span> Smooth</div>
      <div class="row"><span class="key"><kbd>+</kbd> <kbd>-</kbd></span> Scale up / down (3%)</div>
      <div class="row"><span class="key"><kbd>K</kbd></span> Generate from skeleton</div>
      <div class="row"><span class="key"><kbd>F</kbd></span> Skeleton + resample</div>
      <div class="row"><span class="key"><kbd>W</kbd></span> Auto-join nearby strokes</div>
      <div class="row"><span class="key"><kbd>Q</kbd></span> Reduce strokes (aggressive merge)</div>
      <div class="row"><span class="key"><kbd>Y</kbd></span> DiffVG refine (GPU)</div>
      <div class="row"><span class="key"><kbd>1</kbd></span> Place vertex marker (junction)</div>
      <div class="row"><span class="key"><kbd>2</kbd></span> Place termination marker (endpoint)</div>
      <div class="row"><span class="key"><kbd>3</kbd></span> Clear all markers</div>
      <div class="row"><span class="key"><kbd>4</kbd></span> Auto-detect vertices/terminations</div>
      <div class="row"><span class="key"><kbd>Ctrl</kbd>+<kbd>S</kbd></span> Save</div>
      <div class="row"><span class="key"><kbd>Enter</kbd></span> Finish new stroke</div>
      <div class="row"><span class="key"><kbd>Esc</kbd></span> Cancel / deselect</div>
      <div class="row"><span class="key"><kbd>[</kbd> <kbd>]</kbd></span> Prev / Next char</div>
      <div class="row"><span class="key"><kbd>P</kbd></span> Play / Pause recording</div>
    </div>

  </div>
</div>

<script>
const FONT_ID = {{ font.id }};
const CHAR = {{ char|tojson }};
const CHAR_LIST = {{ char_list|tojson }};
const CANVAS_SIZE = 768;
const COORD_SIZE = 224;
const SCALE = CANVAS_SIZE / COORD_SIZE;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const COLORS = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];

let state = {
  strokes: [],
  selectedStroke: -1,
  selectedPoint: -1,
  selectedPointEnd: -1,  // -1 = single point, >= 0 = range end (inclusive)
  selectedMulti: [],     // [{stroke, point}, ...] for marquee selection
  mode: 'select',
  newStrokePoints: [],
  joinFirst: null,  // {stroke, point} - first clicked point for join
  dirty: false,
  markers: []  // [{x, y, type: 'vertex'|'termination'}, ...] structural markers
};

const recorder = {
  sessions: [],
  currentSession: -1,
  playing: false,
  playTimer: null,
  playSpeed: 200,
  playIndex: 0,
  viewSession: -1,
  maxSessions: 50,
  maxFramesPerSession: 2000,
  lastDragFrame: 0
};

function startRecording(label) {
  if (recorder.sessions.length >= recorder.maxSessions) recorder.sessions.shift();
  recorder.sessions.push({label, frames: [], time: Date.now()});
  recorder.currentSession = recorder.sessions.length - 1;
}

function recordFrame(statusMsg) {
  // Auto-create an "Edits" session if no operation session is active
  if (recorder.currentSession < 0) {
    // Reuse last session if it's an "Edits" session with room
    const last = recorder.sessions[recorder.sessions.length - 1];
    if (last && last.label === 'Edits' && last.frames.length < recorder.maxFramesPerSession) {
      recorder.currentSession = recorder.sessions.length - 1;
    } else {
      startRecording('Edits');
    }
  }
  const session = recorder.sessions[recorder.currentSession];
  if (session.frames.length >= recorder.maxFramesPerSession) return;
  session.frames.push({
    strokes: JSON.parse(JSON.stringify(state.strokes)),
    markers: JSON.parse(JSON.stringify(state.markers)),
    status: statusMsg || ''
  });
  // Keep view tracking the latest frame if not in playback
  if (!recorder.playing) {
    // If viewing "All", stay in All mode and track total frame count
    if (recorder.viewSession === -1) {
      recorder.playIndex = _getAllFrames().length - 1;
    } else {
      recorder.viewSession = recorder.currentSession;
      recorder.playIndex = session.frames.length - 1;
    }
  }
  updatePlayerPanel();
}

function stopRecording() {
  if (recorder.currentSession >= 0) {
    if (recorder.viewSession === -1) {
      recorder.playIndex = _getAllFrames().length - 1;
    } else {
      recorder.viewSession = recorder.currentSession;
      recorder.playIndex = recorder.sessions[recorder.currentSession].frames.length - 1;
    }
  }
  recorder.currentSession = -1;
  updatePlayerPanel();
}

let bgImage = null;
let undoStack = [];
let dragging = false;
let multiDragging = false;  // true when dragging a multi-selection
let dragStartX = 0, dragStartY = 0;
let marquee = null;  // {x1, y1, x2, y2} in canvas coords, or null

// --- Data loading ---

function load() {
  fetch(`/api/char/${FONT_ID}?c=${encodeURIComponent(CHAR)}`)
    .then(r => r.json())
    .then(data => {
      state.strokes = data.strokes || [];
      state.markers = data.markers || [];
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.dirty = false;
      undoStack = [];

      if (data.image) {
        const img = new Image();
        img.onload = () => { bgImage = img; draw(); };
        img.src = 'data:image/png;base64,' + data.image;
      } else {
        bgImage = null;
        draw();
      }
      updateStrokeList();
      setStatus('Loaded');
      startRecording('Edits');
      recordFrame('loaded');
      recorder.viewSession = -1;  // default to "All" view
    });
}

function save() {
  fetch(`/api/char/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({strokes: stripVertices(state.strokes), markers: state.markers})
  }).then(r => r.json()).then(d => {
    if (d.ok) {
      state.dirty = false;
      setStatus('Saved', true);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
  });
}

function reloadChar() {
  if (state.dirty && !confirm('Discard unsaved changes?')) return;
  load();
}

// --- Undo ---

function pushUndo() {
  undoStack.push(JSON.stringify({strokes: state.strokes, markers: state.markers}));
  if (undoStack.length > 50) undoStack.shift();
}

function undo() {
  if (!undoStack.length) return;
  const snap = JSON.parse(undoStack.pop());
  if (snap.strokes) {
    state.strokes = snap.strokes;
    state.markers = snap.markers || [];
  } else {
    // Legacy undo entry (just strokes array)
    state.strokes = snap;
  }
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus('Undone');
  recordFrame('undo');
}

// --- Processing (server-side) ---

function serverProcess(url, payload, statusMsg, doneMsg) {
  // Generic server call - sends strokes with locked flags intact.
  // Server preserves locked points during processing.
  pushUndo();
  startRecording(doneMsg);
  setStatus(statusMsg);
  const body = Object.assign({strokes: state.strokes}, payload);
  fetch(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(body)
  }).then(r => r.json()).then(d => {
    if (d.strokes) {
      state.strokes = d.strokes;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.dirty = true;
      draw();
      updateStrokeList();
      setStatus(doneMsg);
      recordFrame(doneMsg);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
    stopRecording();
  });
}

function runConnect() {
  serverProcess(
    `/api/process/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {max_extension: 8.0, smooth: false},
    'Connecting...', 'Connected'
  );
}

function runSmooth() {
  serverProcess(
    `/api/process/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {smooth: true, smooth_sigma: 1.5, connect: false},
    'Smoothing...', 'Smoothed'
  );
}

function runDedup() {
  // Remove duplicate strokes that overlap at the same position.
  // Two strokes are duplicates if every point in the shorter one is within
  // a threshold distance of the nearest point in the other.
  const THRESH = 3.0;  // coord-space units (~3 pixels in 224 space)
  const before = state.strokes.length;
  const keep = [];
  const removed = [];

  for (let i = 0; i < state.strokes.length; i++) {
    let dominated = false;
    for (let j = 0; j < keep.length; j++) {
      if (strokesOverlap(state.strokes[i], state.strokes[keep[j]], THRESH)) {
        dominated = true;
        break;
      }
    }
    if (!dominated) keep.push(i);
    else removed.push(i);
  }

  if (removed.length === 0) {
    setStatus('No duplicates found');
    return;
  }

  pushUndo();
  startRecording('Dedup');
  state.strokes = keep.map(i => state.strokes[i]);
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(`Removed ${removed.length} duplicate strokes (${before} -> ${state.strokes.length})`);
  recordFrame(`Removed ${removed.length} duplicates`);
  stopRecording();
}

function strokesOverlap(a, b, thresh) {
  // Check if the shorter stroke is fully covered by the longer one
  const shorter = a.length <= b.length ? a : b;
  const longer = a.length <= b.length ? b : a;

  for (let i = 0; i < shorter.length; i++) {
    let minDist = Infinity;
    for (let j = 0; j < longer.length; j++) {
      const dx = shorter[i][0] - longer[j][0];
      const dy = shorter[i][1] - longer[j][1];
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < minDist) minDist = d;
    }
    if (minDist > thresh) return false;
  }
  return true;
}

function resampleAdaptive(stroke, baseSpacing) {
  // Resample a stroke with curvature-adaptive spacing.
  // Straight sections get fewer points (up to 2x baseSpacing),
  // curved sections get more points (down to 0.5x baseSpacing).
  if (stroke.length < 2) return stroke;

  // Step 1: compute cumulative arc length and per-segment curvature
  const cumLen = [0];
  for (let i = 1; i < stroke.length; i++) {
    const dx = stroke[i][0] - stroke[i-1][0];
    const dy = stroke[i][1] - stroke[i-1][1];
    cumLen.push(cumLen[i-1] + Math.sqrt(dx * dx + dy * dy));
  }
  const totalLen = cumLen[cumLen.length - 1];
  if (totalLen === 0) return [stroke[0], stroke[0]];

  // Estimate curvature at each original point (angle change per unit length)
  const curvature = new Array(stroke.length).fill(0);
  for (let i = 1; i < stroke.length - 1; i++) {
    const ax = stroke[i][0] - stroke[i-1][0], ay = stroke[i][1] - stroke[i-1][1];
    const bx = stroke[i+1][0] - stroke[i][0], by = stroke[i+1][1] - stroke[i][1];
    const lenA = Math.sqrt(ax*ax + ay*ay);
    const lenB = Math.sqrt(bx*bx + by*by);
    if (lenA > 0.01 && lenB > 0.01) {
      // Angle between consecutive segments
      const dot = (ax*bx + ay*by) / (lenA * lenB);
      const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
      curvature[i] = angle / ((lenA + lenB) / 2);
    }
  }

  // Step 2: walk along the stroke, placing points with adaptive spacing
  const result = [[stroke[0][0], stroke[0][1]]];
  let accumulated = 0;
  let segIdx = 0;

  // Interpolate position at a given arc length
  function interpAt(len) {
    while (segIdx < cumLen.length - 2 && cumLen[segIdx + 1] < len) segIdx++;
    const segLen = cumLen[segIdx + 1] - cumLen[segIdx];
    const t = segLen > 0 ? (len - cumLen[segIdx]) / segLen : 0;
    return [
      stroke[segIdx][0] + t * (stroke[segIdx + 1][0] - stroke[segIdx][0]),
      stroke[segIdx][1] + t * (stroke[segIdx + 1][1] - stroke[segIdx][1])
    ];
  }

  // Sample curvature at a given arc length (interpolate from original points)
  function curvAt(len) {
    let si = 0;
    while (si < cumLen.length - 2 && cumLen[si + 1] < len) si++;
    const segLen = cumLen[si + 1] - cumLen[si];
    const t = segLen > 0 ? (len - cumLen[si]) / segLen : 0;
    return curvature[si] * (1 - t) + curvature[Math.min(si + 1, curvature.length - 1)] * t;
  }

  let pos = 0;
  while (pos < totalLen) {
    // Local curvature determines spacing: high curvature = tighter spacing
    const k = curvAt(pos);
    // Map curvature to spacing multiplier: 0 curvature -> 2x, high curvature -> 0.5x
    const mult = Math.max(0.5, 2.0 - k * 15);
    const step = baseSpacing * mult;
    pos += step;
    if (pos >= totalLen) break;
    segIdx = 0;  // reset for interpAt search
    result.push(interpAt(pos));
  }

  // Always include the last point
  const last = stroke[stroke.length - 1];
  result.push([last[0], last[1]]);
  return result;
}

function runResample() {
  if (state.strokes.length === 0) return;

  // Base spacing in coordinate units (224 space).
  // SDT training: median ~19 pts for typical chars spanning ~100-150 coord units of stroke.
  // That's roughly 6-8 coord units per point. Use 7 as base spacing.
  const BASE_SPACING = 7;

  pushUndo();
  startRecording('Resample');
  const before = state.strokes.reduce((a, s) => a + s.length, 0);
  const result = [];
  for (let i = 0; i < state.strokes.length; i++) {
    const s = state.strokes[i];
    if (isDot(s)) {
      result.push(s);
      continue;
    }
    // Save vertex positions before resampling
    const verts = [];
    for (let pi = 0; pi < s.length; pi++) {
      if (isVertex(s[pi])) verts.push({t: pi / (s.length - 1), x: s[pi][0], y: s[pi][1]});
    }
    const resampled = resampleAdaptive(s, BASE_SPACING);
    // Re-insert vertex points at their nearest position
    for (const v of verts) {
      let bestIdx = 0, bestDist = Infinity;
      for (let ri = 0; ri < resampled.length; ri++) {
        const dx = resampled[ri][0] - v.x, dy = resampled[ri][1] - v.y;
        const d = dx * dx + dy * dy;
        if (d < bestDist) { bestDist = d; bestIdx = ri; }
      }
      resampled[bestIdx] = [v.x, v.y, 1];
    }
    result.push(resampled);
    // Record per-stroke frame
    state.strokes = result.concat(state.strokes.slice(result.length));
    recordFrame(`resample stroke ${i+1}/${state.strokes.length}: ${s.length}→${resampled.length} pts`);
  }
  state.strokes = result;
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.selectedMulti = [];
  state.dirty = true;
  const after = state.strokes.reduce((a, s) => a + s.length, 0);
  draw();
  updateStrokeList();
  setStatus(`Resampled: ${before} → ${after} points`);
  stopRecording();
}

function runScale(factor) {
  if (state.strokes.length === 0) return;
  pushUndo();
  startRecording('Scale');

  // Compute centroid of all points
  let cx = 0, cy = 0, n = 0;
  for (const s of state.strokes) {
    for (const p of s) {
      cx += p[0]; cy += p[1]; n++;
    }
  }
  cx /= n; cy /= n;

  // Scale non-vertex points around centroid, clamped to coord space
  for (const s of state.strokes) {
    for (const p of s) {
      if (isVertex(p)) continue;
      p[0] = Math.max(0, Math.min(COORD_SIZE, cx + (p[0] - cx) * factor));
      p[1] = Math.max(0, Math.min(COORD_SIZE, cy + (p[1] - cy) * factor));
    }
  }

  state.dirty = true;
  draw();
  const pct = Math.round((factor - 1) * 100);
  setStatus(`Scaled ${pct > 0 ? '+' : ''}${pct}%`);
  recordFrame(`Scaled ${pct > 0 ? '+' : ''}${pct}%`);
  stopRecording();
}

function runSnap() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/snap/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Snapping...', 'Snapped to outline'
  );
}

function runCenterBorders() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/center-borders/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Centering in strokes...', 'Centered between borders'
  );
}

function runDiffVG() {
  if (state.strokes.length === 0) {
    setStatus('No strokes to refine');
    return;
  }
  pushUndo();
  startRecording('DiffVG');
  setStatus('Running DiffVG (GPU)...');
  fetch(`/api/diffvg/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({strokes: state.strokes})
  }).then(r => r.json()).then(d => {
    if (d.strokes && d.strokes.length > 0) {
      state.strokes = d.strokes;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedMulti = [];
      state.dirty = true;
      draw();
      updateStrokeList();
      const score = d.score ? d.score.toFixed(3) : '?';
      const elapsed = d.elapsed ? d.elapsed.toFixed(1) : '?';
      setStatus(`DiffVG: score=${score}, ${elapsed}s`);
      recordFrame(`DiffVG: score=${score}`);
    } else {
      setStatus('DiffVG error: ' + (d.error || 'no strokes returned'));
    }
    stopRecording();
  }).catch(err => {
    setStatus('DiffVG failed: ' + err);
    stopRecording();
  });
}

function runSkeleton() {
  if (state.strokes.length > 0 && !confirm('Replace existing strokes with skeleton?')) return;
  pushUndo();
  startRecording('Skeleton');
  setStatus('Generating skeleton...');
  fetch(`/api/skeleton/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (d.strokes) {
      state.strokes = d.strokes;
      if (d.markers) state.markers = d.markers;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedMulti = [];
      state.dirty = true;
      draw();
      updateStrokeList();
      const pts = d.strokes.reduce((a, s) => a + s.length, 0);
      setStatus(`Skeleton: ${d.strokes.length} strokes, ${pts} points`);
      recordFrame(`Skeleton: ${d.strokes.length} strokes, ${pts} pts`);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
    stopRecording();
  });
}

function runSkeletonFull() {
  if (state.strokes.length > 0 && !confirm('Replace existing strokes with skeleton?')) return;
  pushUndo();
  startRecording('Skel+Resample');
  setStatus('Optimizing shapes (streaming)...');
  showStreamBanner('Skel+Resample');

  // Use SSE stream so we can see every optimization step
  if (_optimizeES) { _optimizeES.close(); _optimizeES = null; }
  const url = `/api/optimize-stream/${FONT_ID}?c=${encodeURIComponent(CHAR)}`;
  _optimizeES = new EventSource(url);

  _optimizeES.onmessage = function(ev) {
    const d = JSON.parse(ev.data);
    if (d.error) {
      setStatus('Error: ' + d.error);
      hideStreamBanner();
      _optimizeES.close(); _optimizeES = null;
      // Fall back to non-streaming skeleton
      _skeletonFullFallback();
      return;
    }
    if (d.done) {
      hideStreamBanner(d);
      _optimizeES.close(); _optimizeES = null;
      // Now do client-side post-processing: resample, join, reduce
      _skeletonFullPostProcess();
      return;
    }
    if (d.strokes) {
      state.strokes = d.strokes;
      state.markers = [];
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedMulti = [];
      state.dirty = true;
      draw();
      const phase = d.phase || '';
      updateStreamBanner(d.frame, d.score, phase);
      setStatus(`Optimize F${d.frame}: ${d.score} [${phase}]`);
      recordFrame(`optimize F${d.frame} score=${d.score} ${phase}`);
    }
  };
  _optimizeES.onerror = function() {
    hideStreamBanner();
    _optimizeES.close(); _optimizeES = null;
    // Fall back to non-streaming skeleton
    _skeletonFullFallback();
  };
}

function _skeletonFullFallback() {
  // Non-streaming fallback: use /api/skeleton one-shot
  setStatus('Falling back to one-shot skeleton...');
  fetch(`/api/skeleton/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (!d.strokes) { setStatus('Error: ' + (d.error || 'unknown')); stopRecording(); return; }
    state.strokes = d.strokes;
    if (d.markers) state.markers = d.markers;
    state.dirty = true;
    recordFrame('skeleton (fallback)');
    _skeletonFullPostProcess();
  });
}

function _skeletonFullPostProcess() {
  // Resample each stroke individually with per-stroke frames
  for (let ri = 0; ri < state.strokes.length; ri++) {
    if (isDot(state.strokes[ri])) continue;
    const before = state.strokes[ri].length;
    state.strokes[ri] = resampleAdaptive(state.strokes[ri], 7);
    recordFrame(`resample stroke ${ri+1}/${state.strokes.length}: ${before}→${state.strokes[ri].length} pts`);
  }
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];

  // Detect markers then join/reduce
  fetch(`/api/detect-markers/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(md => {
    if (md.markers) state.markers = md.markers;
    recordFrame('markers detected');

    // Skip auto-join: the optimizer already produced the correct stroke topology.
    // Auto-join would merge nearby endpoints (vline + arcs) into one D-shaped stroke.
    const locked = _lockMarkersToStrokes(state.markers || []);

    draw();
    updateStrokeList();
    const pts = state.strokes.reduce((a, s) => a + s.length, 0);
    const vc = (state.markers || []).filter(m => m.type === 'vertex').length;
    const tc = (state.markers || []).filter(m => m.type === 'termination').length;
    setStatus(`Pipeline: ${state.strokes.length} strokes, ${pts} pts, ${vc}V ${tc}T`);
    stopRecording();
  });
}

// ---- Streaming status banner ----
let _streamTimer = null;
let _streamStartTime = 0;

function showStreamBanner(label) {
  const banner = document.getElementById('streamBanner');
  banner.classList.add('active');
  banner.classList.remove('done');
  document.getElementById('streamLabel').textContent = label || 'Streaming';
  document.getElementById('streamPhase').textContent = '--';
  document.getElementById('streamScore').textContent = '--';
  document.getElementById('streamFrame').textContent = '--';
  document.getElementById('streamStop').style.display = '';
  _streamStartTime = Date.now();
  document.getElementById('streamElapsed').textContent = '0s';
  clearInterval(_streamTimer);
  _streamTimer = setInterval(() => {
    const s = Math.round((Date.now() - _streamStartTime) / 1000);
    document.getElementById('streamElapsed').textContent = s + 's';
  }, 1000);
}

function updateStreamBanner(frame, score, phase) {
  document.getElementById('streamPhase').textContent = phase || '--';
  document.getElementById('streamScore').textContent = score != null ? score : '--';
  document.getElementById('streamFrame').textContent = frame != null ? frame : '--';
}

function hideStreamBanner(doneData) {
  clearInterval(_streamTimer);
  const banner = document.getElementById('streamBanner');
  if (doneData && doneData.score != null) {
    banner.classList.add('done');
    const elapsed = doneData.elapsed != null ? doneData.elapsed + 's' :
                    Math.round((Date.now() - _streamStartTime) / 1000) + 's';
    document.getElementById('streamElapsed').textContent = elapsed;
    const reasonMap = {perfect: 'Perfect', converged: 'Converged', 'time limit': 'Time limit'};
    const reason = reasonMap[doneData.reason] || 'Done';
    const cycles = doneData.cycles ? ` (${doneData.cycles} cycles)` : '';
    document.getElementById('streamLabel').textContent = reason + cycles;
    document.getElementById('streamScore').textContent = doneData.score;
    document.getElementById('streamFrame').textContent = doneData.frame || '--';
    document.getElementById('streamPhase').textContent = reason;
    document.getElementById('streamStop').style.display = 'none';
    // Auto-hide after 8 seconds
    setTimeout(() => { banner.classList.remove('active', 'done'); }, 8000);
  } else {
    banner.classList.remove('active', 'done');
  }
}

function stopStream() {
  if (_optimizeES) {
    _optimizeES.close();
    _optimizeES = null;
    stopRecording();
    hideStreamBanner();
    setStatus('Stream stopped by user');
  }
}

let _optimizeES = null;  // EventSource for live optimize
function runOptimizeLive() {
  if (_optimizeES) { _optimizeES.close(); _optimizeES = null; }
  pushUndo();
  startRecording('Optimize');
  setStatus('Optimizing live...');
  showStreamBanner('Optimize Live');
  const url = `/api/optimize-stream/${FONT_ID}?c=${encodeURIComponent(CHAR)}`;
  _optimizeES = new EventSource(url);
  let frameCount = 0;
  _optimizeES.onmessage = function(ev) {
    const d = JSON.parse(ev.data);
    if (d.error) {
      setStatus('Error: ' + d.error);
      hideStreamBanner();
      _optimizeES.close(); _optimizeES = null;
      stopRecording();
      return;
    }
    if (d.done) {
      const reason = d.reason ? ` (${d.reason})` : '';
      const cycles = d.cycles ? `, ${d.cycles} cycles` : '';
      setStatus(`Optimize done: score=${d.score}, ${d.frame} frames${cycles}${reason}`);
      hideStreamBanner(d);
      _optimizeES.close(); _optimizeES = null;
      stopRecording();
      return;
    }
    if (d.strokes) {
      state.strokes = d.strokes;
      state.markers = [];
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedMulti = [];
      state.dirty = true;
      draw();
      frameCount++;
      const phase = d.phase || '';
      updateStreamBanner(d.frame, d.score, phase);
      setStatus(`Frame ${d.frame}: score=${d.score}`);
      recordFrame(`F${d.frame} score=${d.score}`);
    }
  };
  _optimizeES.onerror = function() {
    setStatus('Optimize stream ended');
    hideStreamBanner();
    _optimizeES.close(); _optimizeES = null;
    stopRecording();
  };
}

function clearShapeCache() {
  fetch(`/api/clear-shape-cache/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST'
  }).then(r => r.json()).then(d => {
    if (d.ok) setStatus('Shape cache cleared for ' + CHAR);
    else setStatus('Error clearing cache');
  });
}

function _autoJoinStrokes() {
  // Marker-guided auto-join: use detected vertices and terminations to
  // decide which strokes to merge.  Strokes meeting at a vertex get
  // paired by best continuation angle.  Termination endpoints are
  // snapped but never joined.  Falls back to proximity join when no
  // markers are available.

  const SNAP_DIST = 15;

  function endDir(stroke, fromEnd) {
    const n = Math.min(4, stroke.length);
    let p0, p1;
    if (fromEnd) { p0 = stroke[stroke.length - n]; p1 = stroke[stroke.length - 1]; }
    else { p0 = stroke[n - 1]; p1 = stroke[0]; }
    const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
    const len = Math.sqrt(dx * dx + dy * dy);
    return len > 0.01 ? [dx / len, dy / len] : [0, 0];
  }

  function dist(a, b) {
    const dx = a[0] - b[0], dy = a[1] - b[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  function distToMarker(p, m) {
    return Math.sqrt((p[0] - m.x) ** 2 + (p[1] - m.y) ** 2);
  }

  const vertices = (state.markers || []).filter(m => m.type === 'vertex');
  const terminations = (state.markers || []).filter(m => m.type === 'termination');

  // ---- Marker-guided join at vertices ----
  let joined = 0;
  let changed = true;

  while (changed) {
    changed = false;

    for (const v of vertices) {
      // Collect stroke endpoints near this vertex
      // Each arrival: { si: stroke index, atEnd: bool }
      let arrivals = [];
      for (let si = 0; si < state.strokes.length; si++) {
        const s = state.strokes[si];
        if (s.length < 2) continue;
        if (distToMarker(s[0], v) < SNAP_DIST)
          arrivals.push({ si, atEnd: false });
        if (distToMarker(s[s.length - 1], v) < SNAP_DIST)
          arrivals.push({ si, atEnd: true });
      }
      if (arrivals.length < 2) continue;

      // Find best continuation pair (most opposite arrival directions)
      let bestScore = -Infinity, bestA = -1, bestB = -1;
      for (let i = 0; i < arrivals.length; i++) {
        for (let j = i + 1; j < arrivals.length; j++) {
          if (arrivals[i].si === arrivals[j].si) continue;
          // endDir points TOWARD the endpoint, so two strokes arriving
          // from opposite sides will have dot ≈ -1
          const d1 = endDir(state.strokes[arrivals[i].si], arrivals[i].atEnd);
          const d2 = endDir(state.strokes[arrivals[j].si], arrivals[j].atEnd);
          const dot = d1[0] * d2[0] + d1[1] * d2[1];
          const score = -dot; // higher = better continuation
          if (score > bestScore) {
            bestScore = score;
            bestA = i; bestB = j;
          }
        }
      }

      // With exactly 2 arrivals, always join (only option at this vertex).
      // With 3+, reject only if best pair arrives from nearly the same
      // direction (dot > 0.5 → score < -0.5, i.e. < 60° apart).
      if (bestA < 0) continue;
      if (arrivals.length > 2 && bestScore < -0.5) continue;

      const a1 = arrivals[bestA], a2 = arrivals[bestB];
      // Orient: s1 ends at vertex, s2 starts at vertex
      let s1 = [...state.strokes[a1.si]];
      let s2 = [...state.strokes[a2.si]];
      if (!a1.atEnd) s1 = s1.reverse();
      if (a2.atEnd) s2 = s2.reverse();

      // Merged stroke: s1 → vertex (locked) → s2
      const merged = [...s1.slice(0, -1), [v.x, v.y, 1], ...s2.slice(1)];

      const higher = Math.max(a1.si, a2.si);
      const lower = Math.min(a1.si, a2.si);
      state.strokes.splice(higher, 1);
      state.strokes[lower] = merged;
      joined++;
      recordFrame(`join at vertex: ${state.strokes.length} strokes remain`);
      changed = true;
      break; // restart - indices are stale
    }
  }

  // ---- Snap remaining endpoints to nearby terminations ----
  for (const t of terminations) {
    for (const stroke of state.strokes) {
      for (const atEnd of [true, false]) {
        const idx = atEnd ? stroke.length - 1 : 0;
        const p = stroke[idx];
        if (distToMarker(p, t) < SNAP_DIST && !isVertex(p)) {
          stroke[idx] = [t.x, t.y, 1];
        }
      }
    }
  }

  // ---- Snap remaining unpaired endpoints to nearby vertices ----
  for (const v of vertices) {
    for (const stroke of state.strokes) {
      for (const atEnd of [true, false]) {
        const idx = atEnd ? stroke.length - 1 : 0;
        const p = stroke[idx];
        if (distToMarker(p, v) < SNAP_DIST && !isVertex(p)) {
          stroke[idx] = [v.x, v.y, 1];
        }
      }
    }
  }

  // ---- Fallback: proximity join for non-marker endpoints ----
  // Merge remaining strokes whose endpoints are close and not at markers
  const PROX_DIST = 12;
  const ANGLE_THRESH = Math.PI / 3;
  changed = true;
  while (changed) {
    changed = false;
    let bestScore = Infinity;
    let bestI = -1, bestJ = -1;
    let bestFlipI = false, bestFlipJ = false;

    for (let i = 0; i < state.strokes.length; i++) {
      if (state.strokes[i].length < 2) continue;
      for (let j = i + 1; j < state.strokes.length; j++) {
        if (state.strokes[j].length < 2) continue;
        const combos = [
          { ei: true,  flipI: false, ej: false, flipJ: false },
          { ei: false, flipI: true,  ej: true,  flipJ: true  },
          { ei: true,  flipI: false, ej: true,  flipJ: true  },
          { ei: false, flipI: true,  ej: false, flipJ: false },
        ];
        for (const c of combos) {
          const rawI = c.ei ? state.strokes[i][state.strokes[i].length - 1] : state.strokes[i][0];
          const rawJ = c.ej ? state.strokes[j][state.strokes[j].length - 1] : state.strokes[j][0];
          if (isVertex(rawI) || isVertex(rawJ)) continue;
          // Don't join at intersection markers
          const inters2 = (state.markers || []).filter(m => m.type === 'intersection');
          let nearInt2 = false;
          for (const m of inters2) {
            if (dist(rawI, [m.x, m.y]) < SNAP_DIST || dist(rawJ, [m.x, m.y]) < SNAP_DIST) {
              nearInt2 = true; break;
            }
          }
          if (nearInt2) continue;
          const d = dist(rawI, rawJ);
          if (d > PROX_DIST) continue;
          const dirI = endDir(state.strokes[i], c.ei);
          const dirJ = endDir(state.strokes[j], !c.ej);
          const dot = dirI[0] * dirJ[0] + dirI[1] * dirJ[1];
          const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
          if (angle > ANGLE_THRESH) continue;
          const score = d + angle * 5;
          if (score < bestScore) {
            bestScore = score;
            bestI = i; bestJ = j;
            bestFlipI = c.flipI; bestFlipJ = c.flipJ;
          }
        }
      }
    }
    if (bestI >= 0) {
      let sI = state.strokes[bestI];
      let sJ = state.strokes[bestJ];
      if (bestFlipI) sI = [...sI].reverse();
      if (bestFlipJ) sJ = [...sJ].reverse();
      state.strokes.splice(bestJ, 1);
      state.strokes[bestI] = sI.concat(sJ);
      joined++;
      recordFrame(`proximity join: ${state.strokes.length} strokes remain`);
      changed = true;
    }
  }

  return joined;
}

function runAutoJoin() {
  if (state.strokes.length < 2) { setStatus('Need at least 2 strokes'); return; }
  pushUndo();
  startRecording('Auto-Join');
  const joined = _autoJoinStrokes();
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];
  state.dirty = true;
  draw();
  updateStrokeList();
  const msg = joined > 0 ? `Auto-joined ${joined} pairs (${state.strokes.length} strokes remain)` : 'No joinable pairs found';
  setStatus(msg);
  recordFrame(msg);
  stopRecording();
}

function _reduceStrokes() {
  // Aggressively merge strokes to reduce count while maintaining coverage.
  // Uses the actual junction angle (how sharp the turn would be at the merge point).

  function dist(a, b) {
    const dx = a[0] - b[0], dy = a[1] - b[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Get direction of travel at a stroke endpoint.
  // Returns unit vector pointing in the direction the stroke is traveling.
  function travelDir(stroke, atEnd) {
    const n = Math.min(5, Math.floor(stroke.length / 2));
    if (n < 1) return [0, 0];
    let p0, p1;
    if (atEnd) {
      p0 = stroke[stroke.length - 1 - n];
      p1 = stroke[stroke.length - 1];
    } else {
      p0 = stroke[n];
      p1 = stroke[0];  // reversed: travel direction goes away from start
    }
    const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
    const len = Math.sqrt(dx * dx + dy * dy);
    return len > 0.01 ? [dx / len, dy / len] : [0, 0];
  }

  // Angle between two unit vectors (0 to PI)
  function angleBetween(d1, d2) {
    const dot = d1[0] * d2[0] + d1[1] * d2[1];
    return Math.acos(Math.max(-1, Math.min(1, dot)));
  }

  // Compute the junction angle if we merge sI(end) -> sJ(start).
  // This is the angle between the travel direction arriving at the junction
  // and the travel direction departing. 0 = straight, PI = U-turn.
  function junctionAngle(sI, sJ) {
    // Travel direction at end of sI (arriving)
    const n = Math.min(5, Math.floor(sI.length / 2));
    if (n < 1) return 0;
    const arrP0 = sI[sI.length - 1 - n], arrP1 = sI[sI.length - 1];
    let adx = arrP1[0] - arrP0[0], ady = arrP1[1] - arrP0[1];
    let alen = Math.sqrt(adx * adx + ady * ady);
    if (alen < 0.01) return 0;
    adx /= alen; ady /= alen;

    // Travel direction at start of sJ (departing)
    const m = Math.min(5, Math.floor(sJ.length / 2));
    if (m < 1) return 0;
    const depP0 = sJ[0], depP1 = sJ[m];
    let ddx = depP1[0] - depP0[0], ddy = depP1[1] - depP0[1];
    let dlen = Math.sqrt(ddx * ddx + ddy * ddy);
    if (dlen < 0.01) return 0;
    ddx /= dlen; ddy /= dlen;

    // Angle between arriving and departing directions (0 = straight continuation)
    const dot = adx * ddx + ady * ddy;
    return Math.acos(Math.max(-1, Math.min(1, dot)));
  }

  let merged = 0;
  let changed = true;
  const MAX_DIST = 30;
  const MAX_ANGLE = Math.PI * 2 / 3;  // 120 degrees max turn at junction

  while (changed) {
    changed = false;
    let bestScore = Infinity;
    let bestI = -1, bestJ = -1;
    let bestFlipI = false, bestFlipJ = false;

    for (let i = 0; i < state.strokes.length; i++) {
      if (state.strokes[i].length < 2) continue;
      for (let j = i + 1; j < state.strokes.length; j++) {
        if (state.strokes[j].length < 2) continue;

        // Try all 4 endpoint combinations: which ends to connect
        // Each combo determines how to orient the two strokes so that
        // sI ends at the junction and sJ starts at the junction.
        const combos = [
          { flipI: false, flipJ: false },  // end-i -> start-j
          { flipI: true,  flipJ: true  },  // start-i(rev) -> end-j(rev)
          { flipI: false, flipJ: true  },  // end-i -> end-j(rev)
          { flipI: true,  flipJ: false },  // start-i(rev) -> start-j
        ];

        for (const c of combos) {
          // Don't merge at locked (vertex/termination) endpoints
          const epI = c.flipI ? state.strokes[i][0] : state.strokes[i][state.strokes[i].length - 1];
          const epJ = c.flipJ ? state.strokes[j][state.strokes[j].length - 1] : state.strokes[j][0];
          if (isVertex(epI) || isVertex(epJ)) continue;
          // Don't merge at intersection markers (strokes overlap there, not join)
          const inters = (state.markers || []).filter(m => m.type === 'intersection');
          let nearIntersection = false;
          for (const m of inters) {
            if (Math.sqrt((epI[0]-m.x)**2 + (epI[1]-m.y)**2) < 15 ||
                Math.sqrt((epJ[0]-m.x)**2 + (epJ[1]-m.y)**2) < 15) {
              nearIntersection = true; break;
            }
          }
          if (nearIntersection) continue;

          // Build oriented copies to check junction
          const sI = c.flipI ? [...state.strokes[i]].reverse() : state.strokes[i];
          const sJ = c.flipJ ? [...state.strokes[j]].reverse() : state.strokes[j];

          // Distance between connecting endpoints
          const pI = sI[sI.length - 1];
          const pJ = sJ[0];
          const d = dist(pI, pJ);
          if (d > MAX_DIST) continue;

          // Junction angle (how sharp the turn is)
          const angle = junctionAngle(sI, sJ);
          if (angle > MAX_ANGLE) continue;

          // Score: prefer close + smooth + absorbing short strokes
          const minLen = Math.min(state.strokes[i].length, state.strokes[j].length);
          const shortBonus = minLen < 20 ? -15 : 0;
          const score = d * 1.5 + angle * 10 + shortBonus;

          if (score < bestScore) {
            bestScore = score;
            bestI = i; bestJ = j;
            bestFlipI = c.flipI; bestFlipJ = c.flipJ;
          }
        }
      }
    }

    if (bestI >= 0 && bestScore < 40) {
      let sI = state.strokes[bestI];
      let sJ = state.strokes[bestJ];
      if (bestFlipI) sI = [...sI].reverse();
      if (bestFlipJ) sJ = [...sJ].reverse();
      state.strokes.splice(bestJ, 1);
      state.strokes[bestI] = sI.concat(sJ);
      merged++;
      recordFrame(`reduce merge: ${state.strokes.length} strokes remain`);
      changed = true;
    }
  }

  return merged;
}

function runReduce() {
  if (state.strokes.length < 2) { setStatus('Need at least 2 strokes'); return; }
  pushUndo();
  startRecording('Reduce');
  const merged = _reduceStrokes();
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];
  state.dirty = true;
  draw();
  updateStrokeList();
  const msg = merged > 0
    ? `Reduced: merged ${merged} pairs (${state.strokes.length} strokes remain)`
    : 'No further reductions possible';
  setStatus(msg);
  recordFrame(msg);
  stopRecording();
}

function runCenter() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/center/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Centering...', 'Centered on glyph'
  );
}

// --- Vertex helpers ---

function isVertex(point) {
  return point.length >= 3 && point[2] === 1;
}

function toggleVertex() {
  // Toggle vertex on selected point(s)
  if (state.selectedMulti.length > 0) {
    pushUndo();
    for (const m of state.selectedMulti) {
      const p = state.strokes[m.stroke][m.point];
      p[2] = isVertex(p) ? 0 : 1;
    }
    state.dirty = true;
    draw();
    setStatus('Toggled vertex on selected points');
    recordFrame('toggle vertex (multi)');
    return;
  }
  if (state.selectedStroke < 0 || state.selectedPoint < 0) {
    setStatus('Select a point first');
    return;
  }
  pushUndo();
  const si = state.selectedStroke;
  const start = state.selectedPoint;
  const end = state.selectedPointEnd >= 0 ? state.selectedPointEnd : start;
  for (let pi = start; pi <= end; pi++) {
    const p = state.strokes[si][pi];
    p[2] = isVertex(p) ? 0 : 1;
  }
  state.dirty = true;
  draw();
  setStatus('Toggled vertex');
  recordFrame('toggle vertex');
}

// Strip vertex flags for DB/server, return clean [x,y] arrays
function stripVertices(strokes) {
  return strokes.map(s => s.map(p => [p[0], p[1]]));
}

// Save vertex positions from current strokes, return a map
function saveVertexPositions(strokes) {
  const verts = [];
  for (let si = 0; si < strokes.length; si++) {
    for (let pi = 0; pi < strokes[si].length; pi++) {
      if (isVertex(strokes[si][pi])) {
        verts.push({stroke: si, point: pi, x: strokes[si][pi][0], y: strokes[si][pi][1]});
      }
    }
  }
  return verts;
}

// Restore vertex positions and flags after a server operation
function restoreVertices(strokes, saved) {
  for (const v of saved) {
    if (v.stroke < strokes.length && v.point < strokes[v.stroke].length) {
      strokes[v.stroke][v.point] = [v.x, v.y, 1];
    }
  }
}

// --- Structural markers ---

function _lockMarkersToStrokes(markers) {
  // Find the nearest stroke point to each vertex/termination marker and lock it.
  // Intersections are ignored - strokes pass through them without locking.
  // If marker has stroke_id, only search within that stroke.
  let locked = 0;
  for (const m of markers) {
    if (m.type === 'intersection') continue;
    let bestDist = Infinity, bestSi = -1, bestPi = -1;
    const siMin = (m.stroke_id !== undefined) ? m.stroke_id : 0;
    const siMax = (m.stroke_id !== undefined) ? m.stroke_id + 1 : state.strokes.length;
    for (let si = siMin; si < siMax && si < state.strokes.length; si++) {
      for (let pi = 0; pi < state.strokes[si].length; pi++) {
        const p = state.strokes[si][pi];
        const dx = p[0] - m.x, dy = p[1] - m.y;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          bestSi = si;
          bestPi = pi;
        }
      }
    }
    if (bestSi >= 0) {
      state.strokes[bestSi][bestPi] = [m.x, m.y, 1];
      locked++;
      recordFrame(`lock ${m.type} → stroke ${bestSi+1} pt ${bestPi}`);
    }
  }
  return locked;
}

function clearPage() {
  if (state.strokes.length === 0 && state.markers.length === 0) { setStatus('Already empty'); return; }
  pushUndo();
  state.strokes = [];
  state.markers = [];
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.dirty = true;
  draw();
  buildStrokeList();
  setStatus('Cleared all strokes and markers');
  recordFrame('clear page');
}

function clearMarkers() {
  if (state.markers.length === 0) { setStatus('No markers to clear'); return; }
  pushUndo();
  state.markers = [];
  state.dirty = true;
  draw();
  setStatus('Cleared all markers');
  recordFrame('clear markers');
}

function detectMarkers() {
  // Detect vertices/terminations from the font glyph image (not from strokes).
  // Skeletonizes the rendered glyph and finds junction clusters (vertices)
  // and endpoints (terminations). If strokes exist, locks nearest points.
  pushUndo();
  setStatus('Analyzing glyph image...');
  fetch(`/api/detect-markers/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (!d.markers) { setStatus('Error: ' + (d.error || 'unknown')); return; }
    state.markers = d.markers;
    let locked = 0;
    if (state.strokes.length > 0) {
      locked = _lockMarkersToStrokes(d.markers);
    }
    state.dirty = true;
    draw();
    updateStrokeList();
    const vc = d.markers.filter(m => m.type === 'vertex').length;
    const tc = d.markers.filter(m => m.type === 'termination').length;
    const ic = d.markers.filter(m => m.type === 'intersection').length;
    const lockMsg = locked > 0 ? `, ${locked} locked to strokes` : '';
    setStatus(`Detected ${vc}V ${tc}T ${ic}I${lockMsg}`);
    recordFrame('detect markers');
  });
}

// --- Dot detection ---

function isDot(stroke) {
  if (stroke.length === 1) return true;
  if (stroke.length === 2) {
    const dx = stroke[1][0] - stroke[0][0];
    const dy = stroke[1][1] - stroke[0][1];
    return Math.sqrt(dx * dx + dy * dy) < 1.0;
  }
  return false;
}

// --- Drawing ---

function draw() {
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // Background: font character image (semi-transparent)
  if (bgImage) {
    ctx.globalAlpha = 0.25;
    ctx.drawImage(bgImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.globalAlpha = 1.0;
  }

  // Draw strokes
  for (let si = 0; si < state.strokes.length; si++) {
    const stroke = state.strokes[si];
    const color = COLORS[si % COLORS.length];
    const selected = (si === state.selectedStroke);
    const isJoinSource = (state.mode === 'joinStroke' && state.joinFirst && si === state.joinFirst.stroke);

    const inMulti = state.selectedMulti.some(m => m.stroke === si);

    if (isDot(stroke)) {
      const cx = stroke[0][0] * SCALE;
      const cy = stroke[0][1] * SCALE;
      const isSelected = (si === state.selectedStroke) || inMulti;
      const r = isSelected ? 9 : 7;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = isSelected ? '#ff0' : '#000';
      ctx.lineWidth = isSelected ? 2.5 : 1.5;
      ctx.stroke();
    } else if (stroke.length >= 2) {
      // Draw glow for join source stroke
      if (isJoinSource) {
        ctx.beginPath();
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 6;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        for (let pi = 0; pi < stroke.length; pi++) {
          const cx = stroke[pi][0] * SCALE;
          const cy = stroke[pi][1] * SCALE;
          if (pi === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = selected || isJoinSource ? 3 : 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for (let pi = 0; pi < stroke.length; pi++) {
        const cx = stroke[pi][0] * SCALE;
        const cy = stroke[pi][1] * SCALE;
        if (pi === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      }
      ctx.stroke();

      for (let pi = 0; pi < stroke.length; pi++) {
        const cx = stroke[pi][0] * SCALE;
        const cy = stroke[pi][1] * SCALE;
        const vert = isVertex(stroke[pi]);
        const isSingle = (si === state.selectedStroke && pi === state.selectedPoint && state.selectedPointEnd < 0);
        const inRange = (si === state.selectedStroke && state.selectedPointEnd >= 0 &&
                         pi >= state.selectedPoint && pi <= state.selectedPointEnd);
        const isJoinPt = (state.mode === 'joinStroke' && state.joinFirst &&
                          si === state.joinFirst.stroke && pi === state.joinFirst.point);
        const isMulti = state.selectedMulti.some(m => m.stroke === si && m.point === pi);
        const highlight = isSingle || inRange || isJoinPt || isMulti;
        const r = highlight ? 6 : 4;
        const fill = isJoinPt ? '#0ff' : (inRange || isMulti) ? '#f80' : (isSingle ? '#fff' : color);
        const border = highlight ? '#ff0' : (vert ? '#0ff' : '#000');
        const lw = highlight ? 2 : (vert ? 2 : 1);
        ctx.fillStyle = fill;
        ctx.strokeStyle = border;
        ctx.lineWidth = lw;
        if (vert) {
          // Square for vertex points
          ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
          ctx.strokeRect(cx - r, cy - r, r * 2, r * 2);
        } else {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
      }

      // Start/End labels (only if no template markers, to avoid duplicates)
      const hasTemplateMarkers = (state.markers || []).some(m => m.type === 'start' || m.type === 'stop');
      if (stroke.length >= 2 && !hasTemplateMarkers) {
        const sx = stroke[0][0] * SCALE, sy = stroke[0][1] * SCALE;
        const ex = stroke[stroke.length-1][0] * SCALE, ey = stroke[stroke.length-1][1] * SCALE;
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Start: green "S"
        ctx.fillStyle = '#0a0';
        ctx.fillText('S', sx, sy - 10);
        // End: red "E"
        ctx.fillStyle = '#d00';
        ctx.fillText('E', ex, ey - 10);
      }
    }
  }

  // Draw structural markers (vertices, terminations, starts, stops, curves)
  for (const m of state.markers) {
    const cx = m.x * SCALE;
    const cy = m.y * SCALE;
    const label = m.label || '';
    ctx.lineWidth = 2;
    if (m.type === 'start') {
      // Triangle pointing right, green - stroke start
      const r = 9;
      ctx.fillStyle = 'rgba(0, 200, 0, 0.8)';
      ctx.strokeStyle = '#0a0';
      ctx.beginPath();
      ctx.moveTo(cx - r * 0.7, cy - r);
      ctx.lineTo(cx + r * 0.7, cy);
      ctx.lineTo(cx - r * 0.7, cy + r);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, cx - 1, cy);
    } else if (m.type === 'stop') {
      // Square, red - stroke end
      const r = 8;
      ctx.fillStyle = 'rgba(220, 0, 0, 0.8)';
      ctx.strokeStyle = '#a00';
      ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
      ctx.strokeRect(cx - r, cy - r, r * 2, r * 2);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, cx, cy);
    } else if (m.type === 'vertex') {
      // Diamond shape, cyan
      const r = 8;
      ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
      ctx.strokeStyle = '#0ff';
      ctx.beginPath();
      ctx.moveTo(cx, cy - r);
      ctx.lineTo(cx + r, cy);
      ctx.lineTo(cx, cy + r);
      ctx.lineTo(cx - r, cy);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label || 'V', cx, cy);
    } else if (m.type === 'curve') {
      // Circle, orange - smooth curve waypoint
      const r = 8;
      ctx.fillStyle = 'rgba(255, 160, 0, 0.8)';
      ctx.strokeStyle = '#f80';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label || 'C', cx, cy);
    } else if (m.type === 'intersection') {
      // Plus/cross shape, dim gray - informational only
      const r = 6;
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
      ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
      ctx.stroke();
    } else {
      // Circle, red/orange - termination (legacy)
      const r = 8;
      ctx.fillStyle = 'rgba(255, 100, 0, 0.7)';
      ctx.strokeStyle = '#f60';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('T', cx, cy);
    }
  }

  // Draw new stroke being added
  if (state.mode === 'addStroke' && state.newStrokePoints.length > 0) {
    const pts = state.newStrokePoints;
    ctx.beginPath();
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    for (let i = 0; i < pts.length; i++) {
      const cx = pts[i][0] * SCALE;
      const cy = pts[i][1] * SCALE;
      if (i === 0) ctx.moveTo(cx, cy);
      else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    for (let i = 0; i < pts.length; i++) {
      const cx = pts[i][0] * SCALE;
      const cy = pts[i][1] * SCALE;
      ctx.beginPath();
      ctx.arc(cx, cy, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#0f0';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  // Draw marquee selection rectangle
  if (marquee) {
    ctx.strokeStyle = '#7eb8f7';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(marquee.x1, marquee.y1, marquee.x2 - marquee.x1, marquee.y2 - marquee.y1);
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(126, 184, 247, 0.1)';
    ctx.fillRect(marquee.x1, marquee.y1, marquee.x2 - marquee.x1, marquee.y2 - marquee.y1);
  }

  // Frame counter overlay
  if (recorder.sessions.length > 0) {
    const totalFrames = recorder.sessions.reduce((a, s) => a + s.frames.length, 0);
    let label;
    if (recorder.viewSession >= 0 && recorder.viewSession < recorder.sessions.length) {
      const s = recorder.sessions[recorder.viewSession];
      label = `S${recorder.viewSession + 1} F${recorder.playIndex + 1}/${s.frames.length} (${totalFrames} total)`;
    } else {
      label = `${recorder.sessions.length} sessions, ${totalFrames} frames`;
    }
    ctx.font = 'bold 12px monospace';
    const tw = ctx.measureText(label).width;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(4, 4, tw + 12, 20);
    ctx.fillStyle = '#0f0';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(label, 10, 8);
  }
}

// --- UI helpers ---

function updateStrokeList() {
  const el = document.getElementById('strokeList');
  let html = '';
  for (let i = 0; i < state.strokes.length; i++) {
    const c = COLORS[i % COLORS.length];
    const sel = i === state.selectedStroke ? ' selected' : '';
    const pts = state.strokes[i].length;
    const label = isDot(state.strokes[i]) ? 'dot' : `${pts} pts`;
    html += `<div class="stroke-item${sel}" onclick="selectStroke(${i})">
      <span class="stroke-color" style="background:${c}"></span>
      Stroke ${i+1} (${label})
      <span class="stroke-delete" onclick="event.stopPropagation();deleteStroke(${i})">&times;</span>
    </div>`;
  }
  el.innerHTML = html;

  // Show range info in status
  if (state.selectedStroke >= 0 && state.selectedPointEnd >= 0) {
    const count = state.selectedPointEnd - state.selectedPoint + 1;
    setStatus(`${count} points selected (${state.selectedPoint}-${state.selectedPointEnd})`);
  }
}

function selectStroke(i) {
  state.selectedStroke = i;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  draw();
  updateStrokeList();
}

function deleteStroke(i) {
  pushUndo();
  state.strokes.splice(i, 1);
  // Focus the next stroke, or the previous if we deleted the last one
  if (state.strokes.length === 0) {
    state.selectedStroke = -1;
  } else if (i < state.strokes.length) {
    state.selectedStroke = i;
  } else {
    state.selectedStroke = state.strokes.length - 1;
  }
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  recordFrame('delete stroke');
}

function deleteSelectedPoint() {
  // Handle multi-selection deletion (marquee)
  if (state.selectedMulti.length > 0) {
    pushUndo();
    // Group by stroke index, sorted descending so splice doesn't shift indices
    const byStroke = {};
    for (const m of state.selectedMulti) {
      if (!byStroke[m.stroke]) byStroke[m.stroke] = [];
      byStroke[m.stroke].push(m.point);
    }
    // Process strokes in reverse order
    const strokeIndices = Object.keys(byStroke).map(Number).sort((a, b) => b - a);
    for (const si of strokeIndices) {
      const pts = byStroke[si].sort((a, b) => b - a);  // reverse order
      for (const pi of pts) {
        state.strokes[si].splice(pi, 1);
      }
      if (state.strokes[si].length === 0) {
        state.strokes.splice(si, 1);
      }
    }
    state.selectedMulti = [];
    state.selectedStroke = -1;
    state.selectedPoint = -1;
    state.selectedPointEnd = -1;
    state.dirty = true;
    draw();
    updateStrokeList();
    recordFrame('delete points (multi)');
    return;
  }

  if (state.selectedStroke < 0 || state.selectedPoint < 0) return;
  pushUndo();
  const si = state.selectedStroke;
  const s = state.strokes[si];
  const start = state.selectedPoint;
  const count = state.selectedPointEnd >= 0 ? (state.selectedPointEnd - start + 1) : 1;
  s.splice(start, count);
  if (s.length === 0) {
    // Stroke is now empty, remove it and focus adjacent stroke
    state.strokes.splice(si, 1);
    if (state.strokes.length === 0) {
      state.selectedStroke = -1;
      state.selectedPoint = -1;
    } else if (si < state.strokes.length) {
      state.selectedStroke = si;
      state.selectedPoint = -1;
    } else {
      state.selectedStroke = state.strokes.length - 1;
      state.selectedPoint = -1;
    }
  } else {
    // Focus the next point, or the previous if we deleted the last one(s)
    if (start < s.length) {
      state.selectedPoint = start;
    } else {
      state.selectedPoint = s.length - 1;
    }
  }
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  recordFrame('delete point');
}

function splitStroke() {
  if (state.selectedStroke < 0 || state.selectedPoint < 0) {
    setStatus('Select a point to split at');
    return;
  }
  const si = state.selectedStroke;
  const pi = state.selectedPoint;
  const s = state.strokes[si];

  if (pi === 0 || pi >= s.length - 1) {
    setStatus('Select a mid-stroke point to split at');
    return;
  }

  pushUndo();
  const first = s.slice(0, pi + 1);
  const second = s.slice(pi);

  state.strokes.splice(si, 1, first, second);
  state.selectedStroke = si + 1;
  state.selectedPoint = 0;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(`Split into ${first.length} + ${second.length} points`);
  recordFrame('split stroke');
}

function startJoin() {
  state.joinFirst = null;
  setMode('joinStroke');
  setStatus('Click a point on the first stroke');
}

function joinStrokes(firstHit, secondHit) {
  // firstHit/secondHit = {stroke, point}
  if (firstHit.stroke === secondHit.stroke) {
    setStatus('Must pick points on different strokes');
    return;
  }

  pushUndo();
  const si1 = firstHit.stroke, pi1 = firstHit.point;
  const si2 = secondHit.stroke, pi2 = secondHit.point;
  const s1 = state.strokes[si1];
  const s2 = state.strokes[si2];

  // Orient stroke 1 so clicked point (pi1) is at the END
  // If pi1 is closer to start, reverse the stroke
  const a = pi1 <= s1.length - 1 - pi1 ? [...s1].reverse() : [...s1];

  // Orient stroke 2 so clicked point (pi2) is at the START
  // If pi2 is closer to end, reverse the stroke
  const b = pi2 >= s2.length - 1 - pi2 ? [...s2].reverse() : [...s2];

  const joined = a.concat(b).map(p => [p[0], p[1]]);

  // Remove both originals (higher index first)
  const hi = Math.max(si1, si2);
  const lo = Math.min(si1, si2);
  state.strokes.splice(hi, 1);
  state.strokes.splice(lo, 1);
  state.strokes.splice(lo, 0, joined);

  state.selectedStroke = lo;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.joinFirst = null;
  state.dirty = true;
  setMode('select');
  draw();
  updateStrokeList();
  setStatus(`Joined strokes (${joined.length} points)`);
  recordFrame('join strokes');
}

function setMode(mode) {
  state.mode = mode;
  state.newStrokePoints = [];
  if (mode !== 'joinStroke') state.joinFirst = null;
  document.getElementById('btnSelect').classList.toggle('active', mode === 'select');
  document.getElementById('btnAddStroke').classList.toggle('active', mode === 'addStroke');
  document.getElementById('btnDeleteStroke').classList.toggle('active', mode === 'deleteStroke');
  document.getElementById('btnJoin').classList.toggle('active', mode === 'joinStroke');
  document.getElementById('btnAddVertex').classList.toggle('active', mode === 'addVertex');
  document.getElementById('btnAddTerm').classList.toggle('active', mode === 'addTermination');
  const cursors = {select: 'crosshair', addStroke: 'copy', joinStroke: 'alias',
                   addVertex: 'cell', addTermination: 'cell'};
  canvas.style.cursor = cursors[mode] || 'not-allowed';
  draw();
}

function setStatus(msg, saved) {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status' + (saved ? ' saved' : '');
}

// --- Hit testing ---

function findPoint(mx, my, threshold) {
  threshold = threshold || 10;
  for (let si = 0; si < state.strokes.length; si++) {
    for (let pi = 0; pi < state.strokes[si].length; pi++) {
      const px = state.strokes[si][pi][0] * SCALE;
      const py = state.strokes[si][pi][1] * SCALE;
      const d = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
      if (d < threshold) return {stroke: si, point: pi, dist: d};
    }
  }
  return null;
}

function findNearestSegment(mx, my, threshold) {
  threshold = threshold || 12;
  let best = null;
  for (let si = 0; si < state.strokes.length; si++) {
    const s = state.strokes[si];
    for (let pi = 0; pi < s.length - 1; pi++) {
      const ax = s[pi][0] * SCALE, ay = s[pi][1] * SCALE;
      const bx = s[pi+1][0] * SCALE, by = s[pi+1][1] * SCALE;
      const d = distToSegment(mx, my, ax, ay, bx, by);
      if (d < threshold && (!best || d < best.dist)) {
        best = {stroke: si, after: pi, dist: d};
      }
    }
  }
  return best;
}

function distToSegment(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const len2 = dx * dx + dy * dy;
  if (len2 === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2);
  let t = ((px - ax) * dx + (py - ay) * dy) / len2;
  t = Math.max(0, Math.min(1, t));
  const nx = ax + t * dx, ny = ay + t * dy;
  return Math.sqrt((px - nx) ** 2 + (py - ny) ** 2);
}

// --- Mouse handlers ---

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (CANVAS_SIZE / rect.width);
  const my = (e.clientY - rect.top) * (CANVAS_SIZE / rect.height);

  if (state.mode === 'select') {
    const hit = findPoint(mx, my);
    if (hit) {
      // Shift+click: extend selection to range on same stroke
      if (e.shiftKey && state.selectedStroke === hit.stroke && state.selectedPoint >= 0) {
        const a = state.selectedPoint;
        const b = hit.point;
        state.selectedPoint = Math.min(a, b);
        state.selectedPointEnd = Math.max(a, b);
        draw();
        updateStrokeList();
        return;
      }
      // If clicking a point that's in the multi-selection, start multi-drag
      if (state.selectedMulti.length > 0 &&
          state.selectedMulti.some(m => m.stroke === hit.stroke && m.point === hit.point)) {
        pushUndo();
        multiDragging = true;
        dragging = true;
        dragStartX = mx;
        dragStartY = my;
        return;
      }
      pushUndo();
      state.selectedStroke = hit.stroke;
      state.selectedPoint = hit.point;
      state.selectedPointEnd = -1;
      state.selectedMulti = [];
      multiDragging = false;
      dragging = true;
      dragStartX = mx;
      dragStartY = my;
      draw();
      updateStrokeList();
      return;
    }

    const seg = findNearestSegment(mx, my);
    if (seg) {
      pushUndo();
      const coordX = mx / SCALE;
      const coordY = my / SCALE;
      state.strokes[seg.stroke].splice(seg.after + 1, 0, [coordX, coordY]);
      state.selectedStroke = seg.stroke;
      state.selectedPoint = seg.after + 1;
      state.selectedPointEnd = -1;
      state.selectedMulti = [];
      state.dirty = true;
      dragging = true;
      draw();
      updateStrokeList();
      recordFrame('insert point');
      return;
    }

    // Start marquee selection on empty space
    state.selectedStroke = -1;
    state.selectedPoint = -1;
    state.selectedPointEnd = -1;
    state.selectedMulti = [];
    marquee = {x1: mx, y1: my, x2: mx, y2: my};
    dragging = true;
    draw();
    updateStrokeList();

  } else if (state.mode === 'addStroke') {
    const coordX = mx / SCALE;
    const coordY = my / SCALE;
    state.newStrokePoints.push([coordX, coordY]);
    draw();
    recordFrame('add stroke point');

  } else if (state.mode === 'deleteStroke') {
    const hit = findPoint(mx, my, 15);
    if (hit) {
      deleteStroke(hit.stroke);
      setMode('select');
      return;
    }
    const seg = findNearestSegment(mx, my, 15);
    if (seg) {
      deleteStroke(seg.stroke);
      setMode('select');
    }

  } else if (state.mode === 'joinStroke') {
    const hit = findPoint(mx, my);
    if (!hit) return;

    if (!state.joinFirst) {
      // First click: remember the point
      state.joinFirst = {stroke: hit.stroke, point: hit.point};
      state.selectedStroke = hit.stroke;
      state.selectedPoint = hit.point;
      state.selectedPointEnd = -1;
      draw();
      updateStrokeList();
      setStatus('Now click a point on the second stroke');
    } else {
      // Second click: join
      if (hit.stroke === state.joinFirst.stroke) {
        setStatus('Must pick a point on a different stroke');
        return;
      }
      joinStrokes(state.joinFirst, hit);
    }

  } else if (state.mode === 'addVertex' || state.mode === 'addTermination') {
    const coordX = mx / SCALE;
    const coordY = my / SCALE;
    const markerType = state.mode === 'addVertex' ? 'vertex' : 'termination';
    // Check if clicking near an existing marker of same type to remove it
    const HIT_DIST = 10;
    let removed = false;
    for (let i = state.markers.length - 1; i >= 0; i--) {
      const m = state.markers[i];
      const d = Math.sqrt((m.x - coordX) ** 2 + (m.y - coordY) ** 2);
      if (d < HIT_DIST && m.type === markerType) {
        state.markers.splice(i, 1);
        removed = true;
        break;
      }
    }
    if (!removed) {
      state.markers.push({x: coordX, y: coordY, type: markerType});
    }
    state.dirty = true;
    draw();
    const vc = state.markers.filter(m => m.type === 'vertex').length;
    const tc = state.markers.filter(m => m.type === 'termination').length;
    const markerMsg = `${removed ? 'remove' : 'add'} ${markerType}`;
    setStatus(`${removed ? 'Removed' : 'Added'} ${markerType} (${vc}V, ${tc}T)`);
    recordFrame(markerMsg);
  }
});

canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (CANVAS_SIZE / rect.width);
  const my = (e.clientY - rect.top) * (CANVAS_SIZE / rect.height);

  if (marquee) {
    marquee.x2 = mx;
    marquee.y2 = my;
    draw();
    return;
  }

  const now = Date.now();
  const shouldRecord = (now - recorder.lastDragFrame) > 80;

  if (multiDragging && state.selectedMulti.length > 0) {
    const dx = (mx - dragStartX) / SCALE;
    const dy = (my - dragStartY) / SCALE;
    for (const m of state.selectedMulti) {
      const p = state.strokes[m.stroke][m.point];
      p[0] = Math.max(0, Math.min(COORD_SIZE, p[0] + dx));
      p[1] = Math.max(0, Math.min(COORD_SIZE, p[1] + dy));
    }
    dragStartX = mx;
    dragStartY = my;
    state.dirty = true;
    draw();
    if (shouldRecord) { recorder.lastDragFrame = now; recordFrame('drag multi'); }
    return;
  }

  if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
    const coordX = Math.max(0, Math.min(COORD_SIZE, mx / SCALE));
    const coordY = Math.max(0, Math.min(COORD_SIZE, my / SCALE));
    state.strokes[state.selectedStroke][state.selectedPoint] = [coordX, coordY];
    state.dirty = true;
    draw();
    if (shouldRecord) { recorder.lastDragFrame = now; recordFrame('drag point'); }
  }
});

canvas.addEventListener('mouseup', () => {
  if (marquee) {
    // Normalize rectangle bounds
    const left = Math.min(marquee.x1, marquee.x2) / SCALE;
    const right = Math.max(marquee.x1, marquee.x2) / SCALE;
    const top = Math.min(marquee.y1, marquee.y2) / SCALE;
    const bottom = Math.max(marquee.y1, marquee.y2) / SCALE;

    // Only select if dragged a meaningful distance (> 5 canvas pixels)
    const w = Math.abs(marquee.x2 - marquee.x1);
    const h = Math.abs(marquee.y2 - marquee.y1);
    if (w > 5 || h > 5) {
      // Find all points inside the rectangle
      const multi = [];
      for (let si = 0; si < state.strokes.length; si++) {
        for (let pi = 0; pi < state.strokes[si].length; pi++) {
          const px = state.strokes[si][pi][0];
          const py = state.strokes[si][pi][1];
          if (px >= left && px <= right && py >= top && py <= bottom) {
            multi.push({stroke: si, point: pi});
          }
        }
      }
      state.selectedMulti = multi;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedPointEnd = -1;
      if (multi.length > 0) {
        setStatus(`${multi.length} points selected`);
      }
    }
    marquee = null;
    draw();
    updateStrokeList();
  } else if (dragging) {
    recordFrame('drop');
  }
  dragging = false;
  multiDragging = false;
});
canvas.addEventListener('mouseleave', () => {
  if (marquee) {
    marquee = null;
    draw();
  }
  dragging = false;
  multiDragging = false;
});

// --- Keyboard handlers ---

document.addEventListener('keydown', e => {
  // Ignore hotkeys when a modifier is held (except specific combos)
  const hasModifier = e.ctrlKey || e.metaKey || e.altKey;

  // Ctrl/Cmd combos
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    save();
    return;
  }
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    undo();
    return;
  }

  // Don't process single-key hotkeys if modifier held
  if (hasModifier) return;

  switch (e.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
        e.preventDefault();
        const s1 = state.strokes[state.selectedStroke];
        if (state.selectedPoint < s1.length - 1) {
          state.selectedPoint++;
          state.selectedPointEnd = -1;
          draw();
          updateStrokeList();
        }
      }
      break;

    case 'ArrowLeft':
    case 'ArrowUp':
      if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
        e.preventDefault();
        if (state.selectedPoint > 0) {
          state.selectedPoint--;
          state.selectedPointEnd = -1;
          draw();
          updateStrokeList();
        }
      }
      break;

    case 'Delete':
    case 'Backspace':
      if (state.selectedMulti.length > 0 || (state.selectedStroke >= 0 && state.selectedPoint >= 0)) {
        e.preventDefault();
        deleteSelectedPoint();
      }
      break;

    case 'Escape':
      if (state.mode === 'addStroke') {
        state.newStrokePoints = [];
        setMode('select');
      } else {
        state.selectedStroke = -1;
        state.selectedPoint = -1;
        state.selectedPointEnd = -1;
        state.selectedMulti = [];
        draw();
        updateStrokeList();
      }
      break;

    case 'Enter':
      if (state.mode === 'addStroke') {
        if (state.newStrokePoints.length >= 1) {
          pushUndo();
          if (state.newStrokePoints.length === 1) {
            const p = state.newStrokePoints[0];
            state.newStrokePoints.push([p[0], p[1]]);
          }
          state.strokes.push(state.newStrokePoints);
          state.dirty = true;
          updateStrokeList();
          recordFrame('new stroke');
        }
        state.newStrokePoints = [];
        setMode('select');
      }
      break;

    case 'v': setMode('select'); break;
    case 'a': setMode('addStroke'); break;
    case 'x': setMode('deleteStroke'); break;
    case 'b': splitStroke(); break;
    case 't': toggleVertex(); break;
    case 'j': startJoin(); break;
    case 'n': runSnap(); break;
    case 'm': runCenterBorders(); break;
    case 'o': runCenter(); break;
    case 'd': runDedup(); break;
    case 'c': runConnect(); break;
    case 'g': runSmooth(); break;
    case 'e': runResample(); break;
    case 'k': runSkeleton(); break;
    case 'f': runSkeletonFull(); break;
    case 'o': runOptimizeLive(); break;
    case 'w': runAutoJoin(); break;
    case 'q': runReduce(); break;
    case 'y': runDiffVG(); break;
    case 'p': togglePlay(); break;
    case '1': setMode('addVertex'); break;
    case '2': setMode('addTermination'); break;
    case '3': clearMarkers(); break;
    case '4': detectMarkers(); break;
    case 'r': reloadChar(); break;
    case '=':
    case '+': runScale(1.03); break;
    case '-': runScale(1/1.03); break;
    case '[': navigateChar(-1); break;
    case ']': navigateChar(1); break;
  }
});

// --- Navigation ---

function navigateChar(dir) {
  const idx = CHAR_LIST.indexOf(CHAR);
  if (idx < 0) return;
  const next = idx + dir;
  if (next < 0 || next >= CHAR_LIST.length) return;
  if (state.dirty && !confirm('Unsaved changes. Continue?')) return;
  window.location.href = `/edit/${FONT_ID}?c=${encodeURIComponent(CHAR_LIST[next])}`;
}

// --- Playback ---

// Build a flat list of all frames across all sessions, with session labels
function _getAllFrames() {
  const all = [];
  for (let si = 0; si < recorder.sessions.length; si++) {
    const s = recorder.sessions[si];
    for (let fi = 0; fi < s.frames.length; fi++) {
      all.push({frame: s.frames[fi], sessionIdx: si, label: s.label, localIdx: fi});
    }
  }
  return all;
}

function _getActiveFrames() {
  const si = recorder.viewSession;
  if (si === -1) return _getAllFrames();
  if (si >= 0 && si < recorder.sessions.length) {
    const s = recorder.sessions[si];
    return s.frames.map((f, fi) => ({frame: f, sessionIdx: si, label: s.label, localIdx: fi}));
  }
  return [];
}

function updatePlayerPanel() {
  const panel = document.getElementById('playerPanel');
  if (recorder.sessions.length === 0) { panel.style.display = 'none'; return; }
  panel.style.display = 'block';
  const sel = document.getElementById('sessionSelect');
  const curVal = sel.value;
  const totalFrames = recorder.sessions.reduce((a, s) => a + s.frames.length, 0);
  let html = `<option value="-1">All (${totalFrames}f)</option>`;
  html += recorder.sessions.map((s, i) =>
    `<option value="${i}">${s.label} (${s.frames.length}f)</option>`
  ).join('');
  sel.innerHTML = html;
  sel.value = recorder.viewSession;
  const frames = _getActiveFrames();
  const tl = document.getElementById('timeline');
  tl.max = Math.max(0, frames.length - 1);
  tl.value = Math.min(recorder.playIndex, frames.length - 1);
  const idx = +tl.value;
  if (frames.length > 0 && idx < frames.length) {
    const f = frames[idx];
    document.getElementById('frameInfo').textContent =
      `F${idx + 1}/${frames.length}` + (f.frame.status ? ' - ' + f.frame.status : '');
  } else {
    document.getElementById('frameInfo').textContent = `0/${frames.length}`;
  }
}

function selectSession() {
  const si = +document.getElementById('sessionSelect').value;
  recorder.viewSession = si;
  recorder.playIndex = 0;
  seekFrame(0);
}

function seekFrame(idx) {
  const frames = _getActiveFrames();
  if (frames.length === 0) return;
  idx = Math.max(0, Math.min(idx, frames.length - 1));
  recorder.playIndex = idx;
  const entry = frames[idx];
  const frame = entry.frame;
  state.strokes = JSON.parse(JSON.stringify(frame.strokes));
  state.markers = JSON.parse(JSON.stringify(frame.markers));
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];
  draw();
  updateStrokeList();
  document.getElementById('timeline').value = idx;
  document.getElementById('frameInfo').textContent =
    `F${idx + 1}/${frames.length}` + (frame.status ? ' - ' + frame.status : '');
  setStatus(`[${entry.label}] Frame ${idx + 1}/${frames.length}${frame.status ? ': ' + frame.status : ''}`);
}

function togglePlay() {
  if (recorder.sessions.length === 0) return;
  if (recorder.playing) {
    clearInterval(recorder.playTimer);
    recorder.playing = false;
    document.getElementById('btnPlayPause').textContent = 'Play';
  } else {
    const frames = _getActiveFrames();
    if (frames.length === 0) return;
    // If at the end, restart from frame 0
    if (recorder.playIndex >= frames.length - 1) {
      recorder.playIndex = 0;
      seekFrame(0);
    }
    recorder.playing = true;
    document.getElementById('btnPlayPause').textContent = 'Pause';
    recorder.playTimer = setInterval(() => {
      const frames = _getActiveFrames();
      if (recorder.playIndex >= frames.length - 1) { togglePlay(); return; }
      seekFrame(recorder.playIndex + 1);
    }, recorder.playSpeed);
  }
}

function playStep(dir) {
  if (recorder.playing) togglePlay();
  seekFrame(recorder.playIndex + dir);
}

function playFirst() {
  if (recorder.playing) togglePlay();
  seekFrame(0);
}

function playLast() {
  if (recorder.playing) togglePlay();
  const frames = _getActiveFrames();
  seekFrame(frames.length - 1);
}

function setPlaySpeed(ms) {
  recorder.playSpeed = ms;
  if (recorder.playing) {
    clearInterval(recorder.playTimer);
    recorder.playTimer = setInterval(() => {
      const frames = _getActiveFrames();
      if (recorder.playIndex >= frames.length - 1) { togglePlay(); return; }
      seekFrame(recorder.playIndex + 1);
    }, recorder.playSpeed);
  }
}

// --- Init ---
load();
</script>
</body>
</html>
