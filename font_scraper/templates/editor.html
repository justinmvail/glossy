<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Edit {{ char }} - {{ font.name }}</title>
<style>
  * { box-sizing: border-box; }
  body { font-family: system-ui, sans-serif; margin: 0; padding: 15px; background: #1a1a2e; color: #eee; }
  a { color: #7eb8f7; text-decoration: none; }
  a:hover { text-decoration: underline; }
  .nav { margin-bottom: 10px; font-size: 14px; }
  .header { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
  .header h1 { margin: 0; font-size: 22px; }
  .header .charLabel { font-size: 28px; background: #222; padding: 2px 14px; border-radius: 4px; }

  .main { display: flex; gap: 20px; }
  .canvas-wrap { position: relative; }
  canvas { background: #fff; border-radius: 4px; cursor: crosshair; }
  .sidebar { min-width: 220px; }

  .toolbar { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
  .toolbar button {
    padding: 5px 10px; border: 1px solid #444; background: #222; color: #eee;
    border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;
  }
  .toolbar button:hover { background: #333; }
  .toolbar button.active { background: #335; border-color: #7eb8f7; }
  .toolbar button.save { background: #254; border-color: #4a8; }
  .toolbar button.save:hover { background: #365; }
  .toolbar button.process { background: #352; border-color: #a84; }
  .toolbar button.process:hover { background: #463; }

  .section-label { font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.5px;
    margin-top: 8px; margin-bottom: 4px; }

  .stroke-list { font-size: 13px; max-height: 250px; overflow-y: auto; }
  .stroke-item {
    padding: 4px 8px; border-radius: 3px; margin-bottom: 2px;
    cursor: pointer; display: flex; align-items: center; gap: 6px;
  }
  .stroke-item:hover { background: #2a2a3e; }
  .stroke-item.selected { background: #2a2a4e; }
  .stroke-color { width: 12px; height: 12px; border-radius: 2px; display: inline-block; flex-shrink: 0; }
  .stroke-delete { margin-left: auto; color: #a55; cursor: pointer; font-size: 16px; }
  .stroke-delete:hover { color: #f66; }

  .status { font-size: 12px; color: #888; margin-top: 10px; }
  .status.saved { color: #4a8; }

  .help { font-size: 11px; color: #555; margin-top: 12px; line-height: 1.7; }
  .help kbd {
    background: #333; padding: 1px 4px; border-radius: 3px; border: 1px solid #444;
    font-family: inherit; font-size: 10px; min-width: 16px; display: inline-block; text-align: center;
  }
  .help .row { display: flex; gap: 6px; }
  .help .key { min-width: 70px; flex-shrink: 0; }
</style>
</head>
<body>
<div class="nav">
  <a href="/">&larr; Fonts</a> &middot; <a href="/font/{{ font.id }}">{{ font.name }}</a>
</div>
<div class="header">
  <h1>{{ font.name }}</h1>
  <span class="charLabel">{{ char }}</span>
</div>
<div class="main">
  <div class="canvas-wrap">
    <canvas id="canvas" width="768" height="768"></canvas>
  </div>
  <div class="sidebar">
    <div class="section-label">Mode</div>
    <div class="toolbar">
      <button id="btnSelect" class="active" onclick="setMode('select')"><kbd>V</kbd> Select</button>
      <button id="btnAddStroke" onclick="setMode('addStroke')"><kbd>A</kbd> + Stroke</button>
      <button id="btnDeleteStroke" onclick="setMode('deleteStroke')"><kbd>X</kbd> - Stroke</button>
      <button id="btnDetectMarkers" class="process" onclick="detectMarkers()"><kbd>4</kbd> Detect V/T</button>
      <button id="btnAddVertex" onclick="setMode('addVertex')"><kbd>1</kbd> + Vertex</button>
      <button id="btnAddTerm" onclick="setMode('addTermination')"><kbd>2</kbd> + Termination</button>
      <button id="btnClearMarkers" onclick="clearMarkers()"><kbd>3</kbd> Clear Markers</button>
    </div>
    <div class="section-label">Edit</div>
    <div class="toolbar">
      <button id="btnDeletePoint" onclick="deleteSelectedPoint()"><kbd>Del</kbd> Del Point</button>
      <button id="btnSplit" onclick="splitStroke()"><kbd>B</kbd> Split</button>
      <button id="btnVertex" onclick="toggleVertex()"><kbd>T</kbd> Vertex</button>
      <button id="btnJoin" onclick="startJoin()"><kbd>J</kbd> Join</button>
      <button id="btnUndo" onclick="undo()"><kbd>Z</kbd> Undo</button>
      <button id="btnReload" onclick="reloadChar()"><kbd>R</kbd> Revert</button>
      <button id="btnClearPage" onclick="clearPage()">Clear Page</button>
    </div>
    <div class="section-label">Process</div>
    <div class="toolbar">
      <button id="btnDedup" class="process" onclick="runDedup()"><kbd>D</kbd> Dedup</button>
      <button id="btnConnect" class="process" onclick="runConnect()"><kbd>C</kbd> Connect</button>
      <button id="btnSmooth" class="process" onclick="runSmooth()"><kbd>G</kbd> Smooth</button>
      <button id="btnSnap" class="process" onclick="runSnap()"><kbd>N</kbd> Snap to Outline</button>
      <button id="btnCenterBorders" class="process" onclick="runCenterBorders()"><kbd>M</kbd> Center in Stroke</button>
      <button id="btnCenter" class="process" onclick="runCenter()"><kbd>O</kbd> Center BBox</button>
      <button id="btnResample" class="process" onclick="runResample()"><kbd>E</kbd> Resample</button>
      <button id="btnScaleUp" class="process" onclick="runScale(1.03)"><kbd>+</kbd> Scale Up</button>
      <button id="btnScaleDn" class="process" onclick="runScale(1/1.03)"><kbd>-</kbd> Scale Down</button>
      <button id="btnSkeleton" class="process" onclick="runSkeleton()"><kbd>K</kbd> Skeleton</button>
      <button id="btnSkeletonFull" class="process" onclick="runSkeletonFull()"><kbd>F</kbd> Skel+Resample</button>
      <button id="btnAutoJoin" class="process" onclick="runAutoJoin()"><kbd>W</kbd> Auto-Join</button>
      <button id="btnReduce" class="process" onclick="runReduce()"><kbd>Q</kbd> Reduce</button>
    </div>
    <div class="section-label">Navigate</div>
    <div class="toolbar">
      <button id="prevChar" onclick="navigateChar(-1)"><kbd>[</kbd> Prev</button>
      <button id="nextChar" onclick="navigateChar(1)"><kbd>]</kbd> Next</button>
      <button id="btnSave" class="save" onclick="save()"><kbd>S</kbd> Save</button>
    </div>

    <div class="section-label">Strokes</div>
    <div id="strokeList" class="stroke-list"></div>
    <div id="status" class="status"></div>

    <div class="help">
      <strong>All Shortcuts</strong>
      <div class="row"><span class="key"><kbd>V</kbd></span> Select mode</div>
      <div class="row"><span class="key"><kbd>A</kbd></span> Add stroke mode</div>
      <div class="row"><span class="key"><kbd>X</kbd></span> Delete stroke mode</div>
      <div class="row"><span class="key"><kbd>&larr;</kbd> <kbd>&rarr;</kbd></span> Prev / next point</div>
      <div class="row"><span class="key"><kbd>Del</kbd></span> Delete point(s)</div>
      <div class="row"><span class="key"><kbd>T</kbd></span> Toggle vertex (locked)</div>
      <div class="row"><span class="key"><kbd>B</kbd></span> Split stroke at point</div>
      <div class="row"><span class="key"><kbd>J</kbd></span> Join two strokes</div>
      <div class="row"><span class="key"><kbd>Shift</kbd>+click</span> Select range</div>
      <div class="row"><span class="key">Drag empty</span> Marquee select</div>
      <div class="row"><span class="key"><kbd>Ctrl</kbd>+<kbd>Z</kbd></span> Undo</div>
      <div class="row"><span class="key"><kbd>R</kbd></span> Revert (reload from DB)</div>
      <div class="row"><span class="key"><kbd>D</kbd></span> Dedup overlapping strokes</div>
      <div class="row"><span class="key"><kbd>C</kbd></span> Connect strokes</div>
      <div class="row"><span class="key"><kbd>N</kbd></span> Snap to outline</div>
      <div class="row"><span class="key"><kbd>M</kbd></span> Center in stroke width</div>
      <div class="row"><span class="key"><kbd>O</kbd></span> Center bbox on glyph</div>
      <div class="row"><span class="key"><kbd>E</kbd></span> Resample (adaptive)</div>
      <div class="row"><span class="key"><kbd>G</kbd></span> Smooth</div>
      <div class="row"><span class="key"><kbd>+</kbd> <kbd>-</kbd></span> Scale up / down (3%)</div>
      <div class="row"><span class="key"><kbd>K</kbd></span> Generate from skeleton</div>
      <div class="row"><span class="key"><kbd>F</kbd></span> Skeleton + resample</div>
      <div class="row"><span class="key"><kbd>W</kbd></span> Auto-join nearby strokes</div>
      <div class="row"><span class="key"><kbd>Q</kbd></span> Reduce strokes (aggressive merge)</div>
      <div class="row"><span class="key"><kbd>1</kbd></span> Place vertex marker (junction)</div>
      <div class="row"><span class="key"><kbd>2</kbd></span> Place termination marker (endpoint)</div>
      <div class="row"><span class="key"><kbd>3</kbd></span> Clear all markers</div>
      <div class="row"><span class="key"><kbd>4</kbd></span> Auto-detect vertices/terminations</div>
      <div class="row"><span class="key"><kbd>Ctrl</kbd>+<kbd>S</kbd></span> Save</div>
      <div class="row"><span class="key"><kbd>Enter</kbd></span> Finish new stroke</div>
      <div class="row"><span class="key"><kbd>Esc</kbd></span> Cancel / deselect</div>
      <div class="row"><span class="key"><kbd>[</kbd> <kbd>]</kbd></span> Prev / Next char</div>
    </div>
  </div>
</div>

<script>
const FONT_ID = {{ font.id }};
const CHAR = {{ char|tojson }};
const CHAR_LIST = {{ char_list|tojson }};
const CANVAS_SIZE = 768;
const COORD_SIZE = 224;
const SCALE = CANVAS_SIZE / COORD_SIZE;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const COLORS = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#a65628','#f781bf','#999999'];

let state = {
  strokes: [],
  selectedStroke: -1,
  selectedPoint: -1,
  selectedPointEnd: -1,  // -1 = single point, >= 0 = range end (inclusive)
  selectedMulti: [],     // [{stroke, point}, ...] for marquee selection
  mode: 'select',
  newStrokePoints: [],
  joinFirst: null,  // {stroke, point} - first clicked point for join
  dirty: false,
  markers: []  // [{x, y, type: 'vertex'|'termination'}, ...] structural markers
};

let bgImage = null;
let undoStack = [];
let dragging = false;
let multiDragging = false;  // true when dragging a multi-selection
let dragStartX = 0, dragStartY = 0;
let marquee = null;  // {x1, y1, x2, y2} in canvas coords, or null

// --- Data loading ---

function load() {
  fetch(`/api/char/${FONT_ID}?c=${encodeURIComponent(CHAR)}`)
    .then(r => r.json())
    .then(data => {
      state.strokes = data.strokes || [];
      state.markers = data.markers || [];
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.dirty = false;
      undoStack = [];

      if (data.image) {
        const img = new Image();
        img.onload = () => { bgImage = img; draw(); };
        img.src = 'data:image/png;base64,' + data.image;
      } else {
        bgImage = null;
        draw();
      }
      updateStrokeList();
      setStatus('Loaded');
    });
}

function save() {
  fetch(`/api/char/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({strokes: stripVertices(state.strokes), markers: state.markers})
  }).then(r => r.json()).then(d => {
    if (d.ok) {
      state.dirty = false;
      setStatus('Saved', true);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
  });
}

function reloadChar() {
  if (state.dirty && !confirm('Discard unsaved changes?')) return;
  load();
}

// --- Undo ---

function pushUndo() {
  undoStack.push(JSON.stringify({strokes: state.strokes, markers: state.markers}));
  if (undoStack.length > 50) undoStack.shift();
}

function undo() {
  if (!undoStack.length) return;
  const snap = JSON.parse(undoStack.pop());
  if (snap.strokes) {
    state.strokes = snap.strokes;
    state.markers = snap.markers || [];
  } else {
    // Legacy undo entry (just strokes array)
    state.strokes = snap;
  }
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus('Undone');
}

// --- Processing (server-side) ---

function serverProcess(url, payload, statusMsg, doneMsg) {
  // Generic server call - sends strokes with locked flags intact.
  // Server preserves locked points during processing.
  pushUndo();
  setStatus(statusMsg);
  const body = Object.assign({strokes: state.strokes}, payload);
  fetch(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(body)
  }).then(r => r.json()).then(d => {
    if (d.strokes) {
      state.strokes = d.strokes;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.dirty = true;
      draw();
      updateStrokeList();
      setStatus(doneMsg);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
  });
}

function runConnect() {
  serverProcess(
    `/api/process/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {max_extension: 8.0, smooth: false},
    'Connecting...', 'Connected'
  );
}

function runSmooth() {
  serverProcess(
    `/api/process/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {smooth: true, smooth_sigma: 1.5, connect: false},
    'Smoothing...', 'Smoothed'
  );
}

function runDedup() {
  // Remove duplicate strokes that overlap at the same position.
  // Two strokes are duplicates if every point in the shorter one is within
  // a threshold distance of the nearest point in the other.
  const THRESH = 3.0;  // coord-space units (~3 pixels in 224 space)
  const before = state.strokes.length;
  const keep = [];
  const removed = [];

  for (let i = 0; i < state.strokes.length; i++) {
    let dominated = false;
    for (let j = 0; j < keep.length; j++) {
      if (strokesOverlap(state.strokes[i], state.strokes[keep[j]], THRESH)) {
        dominated = true;
        break;
      }
    }
    if (!dominated) keep.push(i);
    else removed.push(i);
  }

  if (removed.length === 0) {
    setStatus('No duplicates found');
    return;
  }

  pushUndo();
  state.strokes = keep.map(i => state.strokes[i]);
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(`Removed ${removed.length} duplicate strokes (${before} -> ${state.strokes.length})`);
}

function strokesOverlap(a, b, thresh) {
  // Check if the shorter stroke is fully covered by the longer one
  const shorter = a.length <= b.length ? a : b;
  const longer = a.length <= b.length ? b : a;

  for (let i = 0; i < shorter.length; i++) {
    let minDist = Infinity;
    for (let j = 0; j < longer.length; j++) {
      const dx = shorter[i][0] - longer[j][0];
      const dy = shorter[i][1] - longer[j][1];
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < minDist) minDist = d;
    }
    if (minDist > thresh) return false;
  }
  return true;
}

function resampleAdaptive(stroke, baseSpacing) {
  // Resample a stroke with curvature-adaptive spacing.
  // Straight sections get fewer points (up to 2x baseSpacing),
  // curved sections get more points (down to 0.5x baseSpacing).
  if (stroke.length < 2) return stroke;

  // Step 1: compute cumulative arc length and per-segment curvature
  const cumLen = [0];
  for (let i = 1; i < stroke.length; i++) {
    const dx = stroke[i][0] - stroke[i-1][0];
    const dy = stroke[i][1] - stroke[i-1][1];
    cumLen.push(cumLen[i-1] + Math.sqrt(dx * dx + dy * dy));
  }
  const totalLen = cumLen[cumLen.length - 1];
  if (totalLen === 0) return [stroke[0], stroke[0]];

  // Estimate curvature at each original point (angle change per unit length)
  const curvature = new Array(stroke.length).fill(0);
  for (let i = 1; i < stroke.length - 1; i++) {
    const ax = stroke[i][0] - stroke[i-1][0], ay = stroke[i][1] - stroke[i-1][1];
    const bx = stroke[i+1][0] - stroke[i][0], by = stroke[i+1][1] - stroke[i][1];
    const lenA = Math.sqrt(ax*ax + ay*ay);
    const lenB = Math.sqrt(bx*bx + by*by);
    if (lenA > 0.01 && lenB > 0.01) {
      // Angle between consecutive segments
      const dot = (ax*bx + ay*by) / (lenA * lenB);
      const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
      curvature[i] = angle / ((lenA + lenB) / 2);
    }
  }

  // Step 2: walk along the stroke, placing points with adaptive spacing
  const result = [[stroke[0][0], stroke[0][1]]];
  let accumulated = 0;
  let segIdx = 0;

  // Interpolate position at a given arc length
  function interpAt(len) {
    while (segIdx < cumLen.length - 2 && cumLen[segIdx + 1] < len) segIdx++;
    const segLen = cumLen[segIdx + 1] - cumLen[segIdx];
    const t = segLen > 0 ? (len - cumLen[segIdx]) / segLen : 0;
    return [
      stroke[segIdx][0] + t * (stroke[segIdx + 1][0] - stroke[segIdx][0]),
      stroke[segIdx][1] + t * (stroke[segIdx + 1][1] - stroke[segIdx][1])
    ];
  }

  // Sample curvature at a given arc length (interpolate from original points)
  function curvAt(len) {
    let si = 0;
    while (si < cumLen.length - 2 && cumLen[si + 1] < len) si++;
    const segLen = cumLen[si + 1] - cumLen[si];
    const t = segLen > 0 ? (len - cumLen[si]) / segLen : 0;
    return curvature[si] * (1 - t) + curvature[Math.min(si + 1, curvature.length - 1)] * t;
  }

  let pos = 0;
  while (pos < totalLen) {
    // Local curvature determines spacing: high curvature = tighter spacing
    const k = curvAt(pos);
    // Map curvature to spacing multiplier: 0 curvature -> 2x, high curvature -> 0.5x
    const mult = Math.max(0.5, 2.0 - k * 15);
    const step = baseSpacing * mult;
    pos += step;
    if (pos >= totalLen) break;
    segIdx = 0;  // reset for interpAt search
    result.push(interpAt(pos));
  }

  // Always include the last point
  const last = stroke[stroke.length - 1];
  result.push([last[0], last[1]]);
  return result;
}

function runResample() {
  if (state.strokes.length === 0) return;

  // Base spacing in coordinate units (224 space).
  // SDT training: median ~19 pts for typical chars spanning ~100-150 coord units of stroke.
  // That's roughly 6-8 coord units per point. Use 7 as base spacing.
  const BASE_SPACING = 7;

  pushUndo();
  const before = state.strokes.reduce((a, s) => a + s.length, 0);
  const result = [];
  for (let i = 0; i < state.strokes.length; i++) {
    const s = state.strokes[i];
    if (isDot(s)) {
      result.push(s);
      continue;
    }
    // Save vertex positions before resampling
    const verts = [];
    for (let pi = 0; pi < s.length; pi++) {
      if (isVertex(s[pi])) verts.push({t: pi / (s.length - 1), x: s[pi][0], y: s[pi][1]});
    }
    const resampled = resampleAdaptive(s, BASE_SPACING);
    // Re-insert vertex points at their nearest position
    for (const v of verts) {
      let bestIdx = 0, bestDist = Infinity;
      for (let ri = 0; ri < resampled.length; ri++) {
        const dx = resampled[ri][0] - v.x, dy = resampled[ri][1] - v.y;
        const d = dx * dx + dy * dy;
        if (d < bestDist) { bestDist = d; bestIdx = ri; }
      }
      resampled[bestIdx] = [v.x, v.y, 1];
    }
    result.push(resampled);
  }
  state.strokes = result;
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.selectedMulti = [];
  state.dirty = true;
  const after = state.strokes.reduce((a, s) => a + s.length, 0);
  draw();
  updateStrokeList();
  setStatus(`Resampled: ${before} → ${after} points`);
}

function runScale(factor) {
  if (state.strokes.length === 0) return;
  pushUndo();

  // Compute centroid of all points
  let cx = 0, cy = 0, n = 0;
  for (const s of state.strokes) {
    for (const p of s) {
      cx += p[0]; cy += p[1]; n++;
    }
  }
  cx /= n; cy /= n;

  // Scale non-vertex points around centroid, clamped to coord space
  for (const s of state.strokes) {
    for (const p of s) {
      if (isVertex(p)) continue;
      p[0] = Math.max(0, Math.min(COORD_SIZE, cx + (p[0] - cx) * factor));
      p[1] = Math.max(0, Math.min(COORD_SIZE, cy + (p[1] - cy) * factor));
    }
  }

  state.dirty = true;
  draw();
  const pct = Math.round((factor - 1) * 100);
  setStatus(`Scaled ${pct > 0 ? '+' : ''}${pct}%`);
}

function runSnap() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/snap/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Snapping...', 'Snapped to outline'
  );
}

function runCenterBorders() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/center-borders/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Centering in strokes...', 'Centered between borders'
  );
}

function runSkeleton() {
  if (state.strokes.length > 0 && !confirm('Replace existing strokes with skeleton?')) return;
  pushUndo();
  setStatus('Generating skeleton...');
  fetch(`/api/skeleton/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (d.strokes) {
      state.strokes = d.strokes;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedMulti = [];
      state.dirty = true;
      draw();
      updateStrokeList();
      const pts = d.strokes.reduce((a, s) => a + s.length, 0);
      setStatus(`Skeleton: ${d.strokes.length} strokes, ${pts} points`);
    } else {
      setStatus('Error: ' + (d.error || 'unknown'));
    }
  });
}

function runSkeletonFull() {
  if (state.strokes.length > 0 && !confirm('Replace existing strokes with skeleton?')) return;
  pushUndo();
  setStatus('Generating skeleton...');
  fetch(`/api/skeleton/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (!d.strokes) { setStatus('Error: ' + (d.error || 'unknown')); return; }
    state.strokes = d.strokes;
    state.dirty = true;
    // Resample
    const resampled = [];
    for (const s of state.strokes) {
      if (isDot(s)) { resampled.push(s); continue; }
      resampled.push(resampleAdaptive(s, 7));
    }
    state.strokes = resampled;
    state.selectedStroke = -1;
    state.selectedPoint = -1;
    state.selectedMulti = [];

    // Detect markers FIRST, then auto-join guided by them
    fetch(`/api/detect-markers/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: '{}'
    }).then(r => r.json()).then(md => {
      if (md.markers) {
        state.markers = md.markers;
      }
      // Auto-join uses markers to guide merges at vertices
      const aj = _autoJoinStrokes();
      // Reduce remaining fragments
      const rd = _reduceStrokes();
      // Lock any remaining stroke points to markers
      const locked = _lockMarkersToStrokes(state.markers || []);

      draw();
      updateStrokeList();
      const pts = state.strokes.reduce((a, s) => a + s.length, 0);
      const vc = (state.markers || []).filter(m => m.type === 'vertex').length;
      const tc = (state.markers || []).filter(m => m.type === 'termination').length;
      const ic = (state.markers || []).filter(m => m.type === 'intersection').length;
      setStatus(`Pipeline: ${state.strokes.length} strokes, ${pts} pts, ${vc}V ${tc}T ${ic}I, joined ${aj}, reduced ${rd}`);
    });
  });
}

function _autoJoinStrokes() {
  // Marker-guided auto-join: use detected vertices and terminations to
  // decide which strokes to merge.  Strokes meeting at a vertex get
  // paired by best continuation angle.  Termination endpoints are
  // snapped but never joined.  Falls back to proximity join when no
  // markers are available.

  const SNAP_DIST = 15;

  function endDir(stroke, fromEnd) {
    const n = Math.min(4, stroke.length);
    let p0, p1;
    if (fromEnd) { p0 = stroke[stroke.length - n]; p1 = stroke[stroke.length - 1]; }
    else { p0 = stroke[n - 1]; p1 = stroke[0]; }
    const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
    const len = Math.sqrt(dx * dx + dy * dy);
    return len > 0.01 ? [dx / len, dy / len] : [0, 0];
  }

  function dist(a, b) {
    const dx = a[0] - b[0], dy = a[1] - b[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  function distToMarker(p, m) {
    return Math.sqrt((p[0] - m.x) ** 2 + (p[1] - m.y) ** 2);
  }

  const vertices = (state.markers || []).filter(m => m.type === 'vertex');
  const terminations = (state.markers || []).filter(m => m.type === 'termination');

  // ---- Marker-guided join at vertices ----
  let joined = 0;
  let changed = true;

  while (changed) {
    changed = false;

    for (const v of vertices) {
      // Collect stroke endpoints near this vertex
      // Each arrival: { si: stroke index, atEnd: bool }
      let arrivals = [];
      for (let si = 0; si < state.strokes.length; si++) {
        const s = state.strokes[si];
        if (s.length < 2) continue;
        if (distToMarker(s[0], v) < SNAP_DIST)
          arrivals.push({ si, atEnd: false });
        if (distToMarker(s[s.length - 1], v) < SNAP_DIST)
          arrivals.push({ si, atEnd: true });
      }
      if (arrivals.length < 2) continue;

      // Find best continuation pair (most opposite arrival directions)
      let bestScore = -Infinity, bestA = -1, bestB = -1;
      for (let i = 0; i < arrivals.length; i++) {
        for (let j = i + 1; j < arrivals.length; j++) {
          if (arrivals[i].si === arrivals[j].si) continue;
          // endDir points TOWARD the endpoint, so two strokes arriving
          // from opposite sides will have dot ≈ -1
          const d1 = endDir(state.strokes[arrivals[i].si], arrivals[i].atEnd);
          const d2 = endDir(state.strokes[arrivals[j].si], arrivals[j].atEnd);
          const dot = d1[0] * d2[0] + d1[1] * d2[1];
          const score = -dot; // higher = better continuation
          if (score > bestScore) {
            bestScore = score;
            bestA = i; bestB = j;
          }
        }
      }

      // With exactly 2 arrivals, always join (only option at this vertex).
      // With 3+, reject only if best pair arrives from nearly the same
      // direction (dot > 0.5 → score < -0.5, i.e. < 60° apart).
      if (bestA < 0) continue;
      if (arrivals.length > 2 && bestScore < -0.5) continue;

      const a1 = arrivals[bestA], a2 = arrivals[bestB];
      // Orient: s1 ends at vertex, s2 starts at vertex
      let s1 = [...state.strokes[a1.si]];
      let s2 = [...state.strokes[a2.si]];
      if (!a1.atEnd) s1 = s1.reverse();
      if (a2.atEnd) s2 = s2.reverse();

      // Merged stroke: s1 → vertex (locked) → s2
      const merged = [...s1.slice(0, -1), [v.x, v.y, 1], ...s2.slice(1)];

      const higher = Math.max(a1.si, a2.si);
      const lower = Math.min(a1.si, a2.si);
      state.strokes.splice(higher, 1);
      state.strokes[lower] = merged;
      joined++;
      changed = true;
      break; // restart - indices are stale
    }
  }

  // ---- Snap remaining endpoints to nearby terminations ----
  for (const t of terminations) {
    for (const stroke of state.strokes) {
      for (const atEnd of [true, false]) {
        const idx = atEnd ? stroke.length - 1 : 0;
        const p = stroke[idx];
        if (distToMarker(p, t) < SNAP_DIST && !isVertex(p)) {
          stroke[idx] = [t.x, t.y, 1];
        }
      }
    }
  }

  // ---- Snap remaining unpaired endpoints to nearby vertices ----
  for (const v of vertices) {
    for (const stroke of state.strokes) {
      for (const atEnd of [true, false]) {
        const idx = atEnd ? stroke.length - 1 : 0;
        const p = stroke[idx];
        if (distToMarker(p, v) < SNAP_DIST && !isVertex(p)) {
          stroke[idx] = [v.x, v.y, 1];
        }
      }
    }
  }

  // ---- Fallback: proximity join for non-marker endpoints ----
  // Merge remaining strokes whose endpoints are close and not at markers
  const PROX_DIST = 12;
  const ANGLE_THRESH = Math.PI / 3;
  changed = true;
  while (changed) {
    changed = false;
    let bestScore = Infinity;
    let bestI = -1, bestJ = -1;
    let bestFlipI = false, bestFlipJ = false;

    for (let i = 0; i < state.strokes.length; i++) {
      if (state.strokes[i].length < 2) continue;
      for (let j = i + 1; j < state.strokes.length; j++) {
        if (state.strokes[j].length < 2) continue;
        const combos = [
          { ei: true,  flipI: false, ej: false, flipJ: false },
          { ei: false, flipI: true,  ej: true,  flipJ: true  },
          { ei: true,  flipI: false, ej: true,  flipJ: true  },
          { ei: false, flipI: true,  ej: false, flipJ: false },
        ];
        for (const c of combos) {
          const rawI = c.ei ? state.strokes[i][state.strokes[i].length - 1] : state.strokes[i][0];
          const rawJ = c.ej ? state.strokes[j][state.strokes[j].length - 1] : state.strokes[j][0];
          if (isVertex(rawI) || isVertex(rawJ)) continue;
          const d = dist(rawI, rawJ);
          if (d > PROX_DIST) continue;
          const dirI = endDir(state.strokes[i], c.ei);
          const dirJ = endDir(state.strokes[j], !c.ej);
          const dot = dirI[0] * dirJ[0] + dirI[1] * dirJ[1];
          const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
          if (angle > ANGLE_THRESH) continue;
          const score = d + angle * 5;
          if (score < bestScore) {
            bestScore = score;
            bestI = i; bestJ = j;
            bestFlipI = c.flipI; bestFlipJ = c.flipJ;
          }
        }
      }
    }
    if (bestI >= 0) {
      let sI = state.strokes[bestI];
      let sJ = state.strokes[bestJ];
      if (bestFlipI) sI = [...sI].reverse();
      if (bestFlipJ) sJ = [...sJ].reverse();
      state.strokes.splice(bestJ, 1);
      state.strokes[bestI] = sI.concat(sJ);
      joined++;
      changed = true;
    }
  }

  return joined;
}

function runAutoJoin() {
  if (state.strokes.length < 2) { setStatus('Need at least 2 strokes'); return; }
  pushUndo();
  const joined = _autoJoinStrokes();
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(joined > 0 ? `Auto-joined ${joined} pairs (${state.strokes.length} strokes remain)` : 'No joinable pairs found');
}

function _reduceStrokes() {
  // Aggressively merge strokes to reduce count while maintaining coverage.
  // Uses the actual junction angle (how sharp the turn would be at the merge point).

  function dist(a, b) {
    const dx = a[0] - b[0], dy = a[1] - b[1];
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Get direction of travel at a stroke endpoint.
  // Returns unit vector pointing in the direction the stroke is traveling.
  function travelDir(stroke, atEnd) {
    const n = Math.min(5, Math.floor(stroke.length / 2));
    if (n < 1) return [0, 0];
    let p0, p1;
    if (atEnd) {
      p0 = stroke[stroke.length - 1 - n];
      p1 = stroke[stroke.length - 1];
    } else {
      p0 = stroke[n];
      p1 = stroke[0];  // reversed: travel direction goes away from start
    }
    const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
    const len = Math.sqrt(dx * dx + dy * dy);
    return len > 0.01 ? [dx / len, dy / len] : [0, 0];
  }

  // Angle between two unit vectors (0 to PI)
  function angleBetween(d1, d2) {
    const dot = d1[0] * d2[0] + d1[1] * d2[1];
    return Math.acos(Math.max(-1, Math.min(1, dot)));
  }

  // Compute the junction angle if we merge sI(end) -> sJ(start).
  // This is the angle between the travel direction arriving at the junction
  // and the travel direction departing. 0 = straight, PI = U-turn.
  function junctionAngle(sI, sJ) {
    // Travel direction at end of sI (arriving)
    const n = Math.min(5, Math.floor(sI.length / 2));
    if (n < 1) return 0;
    const arrP0 = sI[sI.length - 1 - n], arrP1 = sI[sI.length - 1];
    let adx = arrP1[0] - arrP0[0], ady = arrP1[1] - arrP0[1];
    let alen = Math.sqrt(adx * adx + ady * ady);
    if (alen < 0.01) return 0;
    adx /= alen; ady /= alen;

    // Travel direction at start of sJ (departing)
    const m = Math.min(5, Math.floor(sJ.length / 2));
    if (m < 1) return 0;
    const depP0 = sJ[0], depP1 = sJ[m];
    let ddx = depP1[0] - depP0[0], ddy = depP1[1] - depP0[1];
    let dlen = Math.sqrt(ddx * ddx + ddy * ddy);
    if (dlen < 0.01) return 0;
    ddx /= dlen; ddy /= dlen;

    // Angle between arriving and departing directions (0 = straight continuation)
    const dot = adx * ddx + ady * ddy;
    return Math.acos(Math.max(-1, Math.min(1, dot)));
  }

  let merged = 0;
  let changed = true;
  const MAX_DIST = 30;
  const MAX_ANGLE = Math.PI * 2 / 3;  // 120 degrees max turn at junction

  while (changed) {
    changed = false;
    let bestScore = Infinity;
    let bestI = -1, bestJ = -1;
    let bestFlipI = false, bestFlipJ = false;

    for (let i = 0; i < state.strokes.length; i++) {
      if (state.strokes[i].length < 2) continue;
      for (let j = i + 1; j < state.strokes.length; j++) {
        if (state.strokes[j].length < 2) continue;

        // Try all 4 endpoint combinations: which ends to connect
        // Each combo determines how to orient the two strokes so that
        // sI ends at the junction and sJ starts at the junction.
        const combos = [
          { flipI: false, flipJ: false },  // end-i -> start-j
          { flipI: true,  flipJ: true  },  // start-i(rev) -> end-j(rev)
          { flipI: false, flipJ: true  },  // end-i -> end-j(rev)
          { flipI: true,  flipJ: false },  // start-i(rev) -> start-j
        ];

        for (const c of combos) {
          // Don't merge at locked (vertex/termination) endpoints
          const epI = c.flipI ? state.strokes[i][0] : state.strokes[i][state.strokes[i].length - 1];
          const epJ = c.flipJ ? state.strokes[j][state.strokes[j].length - 1] : state.strokes[j][0];
          if (isVertex(epI) || isVertex(epJ)) continue;

          // Build oriented copies to check junction
          const sI = c.flipI ? [...state.strokes[i]].reverse() : state.strokes[i];
          const sJ = c.flipJ ? [...state.strokes[j]].reverse() : state.strokes[j];

          // Distance between connecting endpoints
          const pI = sI[sI.length - 1];
          const pJ = sJ[0];
          const d = dist(pI, pJ);
          if (d > MAX_DIST) continue;

          // Junction angle (how sharp the turn is)
          const angle = junctionAngle(sI, sJ);
          if (angle > MAX_ANGLE) continue;

          // Score: prefer close + smooth + absorbing short strokes
          const minLen = Math.min(state.strokes[i].length, state.strokes[j].length);
          const shortBonus = minLen < 20 ? -15 : 0;
          const score = d * 1.5 + angle * 10 + shortBonus;

          if (score < bestScore) {
            bestScore = score;
            bestI = i; bestJ = j;
            bestFlipI = c.flipI; bestFlipJ = c.flipJ;
          }
        }
      }
    }

    if (bestI >= 0 && bestScore < 40) {
      let sI = state.strokes[bestI];
      let sJ = state.strokes[bestJ];
      if (bestFlipI) sI = [...sI].reverse();
      if (bestFlipJ) sJ = [...sJ].reverse();
      state.strokes.splice(bestJ, 1);
      state.strokes[bestI] = sI.concat(sJ);
      merged++;
      changed = true;
    }
  }

  return merged;
}

function runReduce() {
  if (state.strokes.length < 2) { setStatus('Need at least 2 strokes'); return; }
  pushUndo();
  const merged = _reduceStrokes();
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.selectedMulti = [];
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(merged > 0
    ? `Reduced: merged ${merged} pairs (${state.strokes.length} strokes remain)`
    : 'No further reductions possible');
}

function runCenter() {
  if (state.strokes.length === 0) return;
  serverProcess(
    `/api/center/${FONT_ID}?c=${encodeURIComponent(CHAR)}`,
    {}, 'Centering...', 'Centered on glyph'
  );
}

// --- Vertex helpers ---

function isVertex(point) {
  return point.length >= 3 && point[2] === 1;
}

function toggleVertex() {
  // Toggle vertex on selected point(s)
  if (state.selectedMulti.length > 0) {
    pushUndo();
    for (const m of state.selectedMulti) {
      const p = state.strokes[m.stroke][m.point];
      p[2] = isVertex(p) ? 0 : 1;
    }
    state.dirty = true;
    draw();
    setStatus('Toggled vertex on selected points');
    return;
  }
  if (state.selectedStroke < 0 || state.selectedPoint < 0) {
    setStatus('Select a point first');
    return;
  }
  pushUndo();
  const si = state.selectedStroke;
  const start = state.selectedPoint;
  const end = state.selectedPointEnd >= 0 ? state.selectedPointEnd : start;
  for (let pi = start; pi <= end; pi++) {
    const p = state.strokes[si][pi];
    p[2] = isVertex(p) ? 0 : 1;
  }
  state.dirty = true;
  draw();
  setStatus('Toggled vertex');
}

// Strip vertex flags for DB/server, return clean [x,y] arrays
function stripVertices(strokes) {
  return strokes.map(s => s.map(p => [p[0], p[1]]));
}

// Save vertex positions from current strokes, return a map
function saveVertexPositions(strokes) {
  const verts = [];
  for (let si = 0; si < strokes.length; si++) {
    for (let pi = 0; pi < strokes[si].length; pi++) {
      if (isVertex(strokes[si][pi])) {
        verts.push({stroke: si, point: pi, x: strokes[si][pi][0], y: strokes[si][pi][1]});
      }
    }
  }
  return verts;
}

// Restore vertex positions and flags after a server operation
function restoreVertices(strokes, saved) {
  for (const v of saved) {
    if (v.stroke < strokes.length && v.point < strokes[v.stroke].length) {
      strokes[v.stroke][v.point] = [v.x, v.y, 1];
    }
  }
}

// --- Structural markers ---

function _lockMarkersToStrokes(markers) {
  // Find the nearest stroke point to each vertex/termination marker and lock it.
  // Intersections are ignored - strokes pass through them without locking.
  let locked = 0;
  for (const m of markers) {
    if (m.type === 'intersection') continue;
    let bestDist = Infinity, bestSi = -1, bestPi = -1;
    for (let si = 0; si < state.strokes.length; si++) {
      for (let pi = 0; pi < state.strokes[si].length; pi++) {
        const p = state.strokes[si][pi];
        const dx = p[0] - m.x, dy = p[1] - m.y;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          bestSi = si;
          bestPi = pi;
        }
      }
    }
    if (bestSi >= 0) {
      state.strokes[bestSi][bestPi] = [m.x, m.y, 1];
      locked++;
    }
  }
  return locked;
}

function clearPage() {
  if (state.strokes.length === 0 && state.markers.length === 0) { setStatus('Already empty'); return; }
  pushUndo();
  state.strokes = [];
  state.markers = [];
  state.selectedStroke = -1;
  state.selectedPoint = -1;
  state.dirty = true;
  draw();
  buildStrokeList();
  setStatus('Cleared all strokes and markers');
}

function clearMarkers() {
  if (state.markers.length === 0) { setStatus('No markers to clear'); return; }
  pushUndo();
  state.markers = [];
  state.dirty = true;
  draw();
  setStatus('Cleared all markers');
}

function detectMarkers() {
  // Detect vertices/terminations from the font glyph image (not from strokes).
  // Skeletonizes the rendered glyph and finds junction clusters (vertices)
  // and endpoints (terminations). If strokes exist, locks nearest points.
  pushUndo();
  setStatus('Analyzing glyph image...');
  fetch(`/api/detect-markers/${FONT_ID}?c=${encodeURIComponent(CHAR)}`, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: '{}'
  }).then(r => r.json()).then(d => {
    if (!d.markers) { setStatus('Error: ' + (d.error || 'unknown')); return; }
    state.markers = d.markers;
    let locked = 0;
    if (state.strokes.length > 0) {
      locked = _lockMarkersToStrokes(d.markers);
    }
    state.dirty = true;
    draw();
    updateStrokeList();
    const vc = d.markers.filter(m => m.type === 'vertex').length;
    const tc = d.markers.filter(m => m.type === 'termination').length;
    const ic = d.markers.filter(m => m.type === 'intersection').length;
    const lockMsg = locked > 0 ? `, ${locked} locked to strokes` : '';
    setStatus(`Detected ${vc}V ${tc}T ${ic}I${lockMsg}`);
  });
}

// --- Dot detection ---

function isDot(stroke) {
  if (stroke.length === 1) return true;
  if (stroke.length === 2) {
    const dx = stroke[1][0] - stroke[0][0];
    const dy = stroke[1][1] - stroke[0][1];
    return Math.sqrt(dx * dx + dy * dy) < 1.0;
  }
  return false;
}

// --- Drawing ---

function draw() {
  ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

  // Background: font character image (semi-transparent)
  if (bgImage) {
    ctx.globalAlpha = 0.25;
    ctx.drawImage(bgImage, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.globalAlpha = 1.0;
  }

  // Draw strokes
  for (let si = 0; si < state.strokes.length; si++) {
    const stroke = state.strokes[si];
    const color = COLORS[si % COLORS.length];
    const selected = (si === state.selectedStroke);
    const isJoinSource = (state.mode === 'joinStroke' && state.joinFirst && si === state.joinFirst.stroke);

    const inMulti = state.selectedMulti.some(m => m.stroke === si);

    if (isDot(stroke)) {
      const cx = stroke[0][0] * SCALE;
      const cy = stroke[0][1] * SCALE;
      const isSelected = (si === state.selectedStroke) || inMulti;
      const r = isSelected ? 9 : 7;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = isSelected ? '#ff0' : '#000';
      ctx.lineWidth = isSelected ? 2.5 : 1.5;
      ctx.stroke();
    } else if (stroke.length >= 2) {
      // Draw glow for join source stroke
      if (isJoinSource) {
        ctx.beginPath();
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 6;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        for (let pi = 0; pi < stroke.length; pi++) {
          const cx = stroke[pi][0] * SCALE;
          const cy = stroke[pi][1] * SCALE;
          if (pi === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        }
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = selected || isJoinSource ? 3 : 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for (let pi = 0; pi < stroke.length; pi++) {
        const cx = stroke[pi][0] * SCALE;
        const cy = stroke[pi][1] * SCALE;
        if (pi === 0) ctx.moveTo(cx, cy);
        else ctx.lineTo(cx, cy);
      }
      ctx.stroke();

      for (let pi = 0; pi < stroke.length; pi++) {
        const cx = stroke[pi][0] * SCALE;
        const cy = stroke[pi][1] * SCALE;
        const vert = isVertex(stroke[pi]);
        const isSingle = (si === state.selectedStroke && pi === state.selectedPoint && state.selectedPointEnd < 0);
        const inRange = (si === state.selectedStroke && state.selectedPointEnd >= 0 &&
                         pi >= state.selectedPoint && pi <= state.selectedPointEnd);
        const isJoinPt = (state.mode === 'joinStroke' && state.joinFirst &&
                          si === state.joinFirst.stroke && pi === state.joinFirst.point);
        const isMulti = state.selectedMulti.some(m => m.stroke === si && m.point === pi);
        const highlight = isSingle || inRange || isJoinPt || isMulti;
        const r = highlight ? 6 : 4;
        const fill = isJoinPt ? '#0ff' : (inRange || isMulti) ? '#f80' : (isSingle ? '#fff' : color);
        const border = highlight ? '#ff0' : (vert ? '#0ff' : '#000');
        const lw = highlight ? 2 : (vert ? 2 : 1);
        ctx.fillStyle = fill;
        ctx.strokeStyle = border;
        ctx.lineWidth = lw;
        if (vert) {
          // Square for vertex points
          ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
          ctx.strokeRect(cx - r, cy - r, r * 2, r * 2);
        } else {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }
      }

      // Start/End labels
      if (stroke.length >= 2) {
        const sx = stroke[0][0] * SCALE, sy = stroke[0][1] * SCALE;
        const ex = stroke[stroke.length-1][0] * SCALE, ey = stroke[stroke.length-1][1] * SCALE;
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Start: green "S"
        ctx.fillStyle = '#0a0';
        ctx.fillText('S', sx, sy - 10);
        // End: red "E"
        ctx.fillStyle = '#d00';
        ctx.fillText('E', ex, ey - 10);
      }
    }
  }

  // Draw structural markers (vertices, terminations, intersections)
  for (const m of state.markers) {
    const cx = m.x * SCALE;
    const cy = m.y * SCALE;
    ctx.lineWidth = 2;
    if (m.type === 'vertex') {
      // Diamond shape, cyan
      const r = 8;
      ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
      ctx.strokeStyle = '#0ff';
      ctx.beginPath();
      ctx.moveTo(cx, cy - r);
      ctx.lineTo(cx + r, cy);
      ctx.lineTo(cx, cy + r);
      ctx.lineTo(cx - r, cy);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('V', cx, cy);
    } else if (m.type === 'intersection') {
      // Plus/cross shape, dim gray - informational only
      const r = 6;
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
      ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
      ctx.stroke();
    } else {
      // Circle, red/orange - termination
      const r = 8;
      ctx.fillStyle = 'rgba(255, 100, 0, 0.7)';
      ctx.strokeStyle = '#f60';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('T', cx, cy);
    }
  }

  // Draw new stroke being added
  if (state.mode === 'addStroke' && state.newStrokePoints.length > 0) {
    const pts = state.newStrokePoints;
    ctx.beginPath();
    ctx.strokeStyle = '#0f0';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    for (let i = 0; i < pts.length; i++) {
      const cx = pts[i][0] * SCALE;
      const cy = pts[i][1] * SCALE;
      if (i === 0) ctx.moveTo(cx, cy);
      else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    for (let i = 0; i < pts.length; i++) {
      const cx = pts[i][0] * SCALE;
      const cy = pts[i][1] * SCALE;
      ctx.beginPath();
      ctx.arc(cx, cy, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#0f0';
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  // Draw marquee selection rectangle
  if (marquee) {
    ctx.strokeStyle = '#7eb8f7';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(marquee.x1, marquee.y1, marquee.x2 - marquee.x1, marquee.y2 - marquee.y1);
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(126, 184, 247, 0.1)';
    ctx.fillRect(marquee.x1, marquee.y1, marquee.x2 - marquee.x1, marquee.y2 - marquee.y1);
  }
}

// --- UI helpers ---

function updateStrokeList() {
  const el = document.getElementById('strokeList');
  let html = '';
  for (let i = 0; i < state.strokes.length; i++) {
    const c = COLORS[i % COLORS.length];
    const sel = i === state.selectedStroke ? ' selected' : '';
    const pts = state.strokes[i].length;
    const label = isDot(state.strokes[i]) ? 'dot' : `${pts} pts`;
    html += `<div class="stroke-item${sel}" onclick="selectStroke(${i})">
      <span class="stroke-color" style="background:${c}"></span>
      Stroke ${i+1} (${label})
      <span class="stroke-delete" onclick="event.stopPropagation();deleteStroke(${i})">&times;</span>
    </div>`;
  }
  el.innerHTML = html;

  // Show range info in status
  if (state.selectedStroke >= 0 && state.selectedPointEnd >= 0) {
    const count = state.selectedPointEnd - state.selectedPoint + 1;
    setStatus(`${count} points selected (${state.selectedPoint}-${state.selectedPointEnd})`);
  }
}

function selectStroke(i) {
  state.selectedStroke = i;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  draw();
  updateStrokeList();
}

function deleteStroke(i) {
  pushUndo();
  state.strokes.splice(i, 1);
  // Focus the next stroke, or the previous if we deleted the last one
  if (state.strokes.length === 0) {
    state.selectedStroke = -1;
  } else if (i < state.strokes.length) {
    state.selectedStroke = i;
  } else {
    state.selectedStroke = state.strokes.length - 1;
  }
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
}

function deleteSelectedPoint() {
  // Handle multi-selection deletion (marquee)
  if (state.selectedMulti.length > 0) {
    pushUndo();
    // Group by stroke index, sorted descending so splice doesn't shift indices
    const byStroke = {};
    for (const m of state.selectedMulti) {
      if (!byStroke[m.stroke]) byStroke[m.stroke] = [];
      byStroke[m.stroke].push(m.point);
    }
    // Process strokes in reverse order
    const strokeIndices = Object.keys(byStroke).map(Number).sort((a, b) => b - a);
    for (const si of strokeIndices) {
      const pts = byStroke[si].sort((a, b) => b - a);  // reverse order
      for (const pi of pts) {
        state.strokes[si].splice(pi, 1);
      }
      if (state.strokes[si].length === 0) {
        state.strokes.splice(si, 1);
      }
    }
    state.selectedMulti = [];
    state.selectedStroke = -1;
    state.selectedPoint = -1;
    state.selectedPointEnd = -1;
    state.dirty = true;
    draw();
    updateStrokeList();
    return;
  }

  if (state.selectedStroke < 0 || state.selectedPoint < 0) return;
  pushUndo();
  const si = state.selectedStroke;
  const s = state.strokes[si];
  const start = state.selectedPoint;
  const count = state.selectedPointEnd >= 0 ? (state.selectedPointEnd - start + 1) : 1;
  s.splice(start, count);
  if (s.length === 0) {
    // Stroke is now empty, remove it and focus adjacent stroke
    state.strokes.splice(si, 1);
    if (state.strokes.length === 0) {
      state.selectedStroke = -1;
      state.selectedPoint = -1;
    } else if (si < state.strokes.length) {
      state.selectedStroke = si;
      state.selectedPoint = -1;
    } else {
      state.selectedStroke = state.strokes.length - 1;
      state.selectedPoint = -1;
    }
  } else {
    // Focus the next point, or the previous if we deleted the last one(s)
    if (start < s.length) {
      state.selectedPoint = start;
    } else {
      state.selectedPoint = s.length - 1;
    }
  }
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
}

function splitStroke() {
  if (state.selectedStroke < 0 || state.selectedPoint < 0) {
    setStatus('Select a point to split at');
    return;
  }
  const si = state.selectedStroke;
  const pi = state.selectedPoint;
  const s = state.strokes[si];

  if (pi === 0 || pi >= s.length - 1) {
    setStatus('Select a mid-stroke point to split at');
    return;
  }

  pushUndo();
  const first = s.slice(0, pi + 1);
  const second = s.slice(pi);

  state.strokes.splice(si, 1, first, second);
  state.selectedStroke = si + 1;
  state.selectedPoint = 0;
  state.selectedPointEnd = -1;
  state.dirty = true;
  draw();
  updateStrokeList();
  setStatus(`Split into ${first.length} + ${second.length} points`);
}

function startJoin() {
  state.joinFirst = null;
  setMode('joinStroke');
  setStatus('Click a point on the first stroke');
}

function joinStrokes(firstHit, secondHit) {
  // firstHit/secondHit = {stroke, point}
  if (firstHit.stroke === secondHit.stroke) {
    setStatus('Must pick points on different strokes');
    return;
  }

  pushUndo();
  const si1 = firstHit.stroke, pi1 = firstHit.point;
  const si2 = secondHit.stroke, pi2 = secondHit.point;
  const s1 = state.strokes[si1];
  const s2 = state.strokes[si2];

  // Orient stroke 1 so clicked point (pi1) is at the END
  // If pi1 is closer to start, reverse the stroke
  const a = pi1 <= s1.length - 1 - pi1 ? [...s1].reverse() : [...s1];

  // Orient stroke 2 so clicked point (pi2) is at the START
  // If pi2 is closer to end, reverse the stroke
  const b = pi2 >= s2.length - 1 - pi2 ? [...s2].reverse() : [...s2];

  const joined = a.concat(b).map(p => [p[0], p[1]]);

  // Remove both originals (higher index first)
  const hi = Math.max(si1, si2);
  const lo = Math.min(si1, si2);
  state.strokes.splice(hi, 1);
  state.strokes.splice(lo, 1);
  state.strokes.splice(lo, 0, joined);

  state.selectedStroke = lo;
  state.selectedPoint = -1;
  state.selectedPointEnd = -1;
  state.joinFirst = null;
  state.dirty = true;
  setMode('select');
  draw();
  updateStrokeList();
  setStatus(`Joined strokes (${joined.length} points)`);
}

function setMode(mode) {
  state.mode = mode;
  state.newStrokePoints = [];
  if (mode !== 'joinStroke') state.joinFirst = null;
  document.getElementById('btnSelect').classList.toggle('active', mode === 'select');
  document.getElementById('btnAddStroke').classList.toggle('active', mode === 'addStroke');
  document.getElementById('btnDeleteStroke').classList.toggle('active', mode === 'deleteStroke');
  document.getElementById('btnJoin').classList.toggle('active', mode === 'joinStroke');
  document.getElementById('btnAddVertex').classList.toggle('active', mode === 'addVertex');
  document.getElementById('btnAddTerm').classList.toggle('active', mode === 'addTermination');
  const cursors = {select: 'crosshair', addStroke: 'copy', joinStroke: 'alias',
                   addVertex: 'cell', addTermination: 'cell'};
  canvas.style.cursor = cursors[mode] || 'not-allowed';
  draw();
}

function setStatus(msg, saved) {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status' + (saved ? ' saved' : '');
}

// --- Hit testing ---

function findPoint(mx, my, threshold) {
  threshold = threshold || 10;
  for (let si = 0; si < state.strokes.length; si++) {
    for (let pi = 0; pi < state.strokes[si].length; pi++) {
      const px = state.strokes[si][pi][0] * SCALE;
      const py = state.strokes[si][pi][1] * SCALE;
      const d = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
      if (d < threshold) return {stroke: si, point: pi, dist: d};
    }
  }
  return null;
}

function findNearestSegment(mx, my, threshold) {
  threshold = threshold || 12;
  let best = null;
  for (let si = 0; si < state.strokes.length; si++) {
    const s = state.strokes[si];
    for (let pi = 0; pi < s.length - 1; pi++) {
      const ax = s[pi][0] * SCALE, ay = s[pi][1] * SCALE;
      const bx = s[pi+1][0] * SCALE, by = s[pi+1][1] * SCALE;
      const d = distToSegment(mx, my, ax, ay, bx, by);
      if (d < threshold && (!best || d < best.dist)) {
        best = {stroke: si, after: pi, dist: d};
      }
    }
  }
  return best;
}

function distToSegment(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const len2 = dx * dx + dy * dy;
  if (len2 === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2);
  let t = ((px - ax) * dx + (py - ay) * dy) / len2;
  t = Math.max(0, Math.min(1, t));
  const nx = ax + t * dx, ny = ay + t * dy;
  return Math.sqrt((px - nx) ** 2 + (py - ny) ** 2);
}

// --- Mouse handlers ---

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (CANVAS_SIZE / rect.width);
  const my = (e.clientY - rect.top) * (CANVAS_SIZE / rect.height);

  if (state.mode === 'select') {
    const hit = findPoint(mx, my);
    if (hit) {
      // Shift+click: extend selection to range on same stroke
      if (e.shiftKey && state.selectedStroke === hit.stroke && state.selectedPoint >= 0) {
        const a = state.selectedPoint;
        const b = hit.point;
        state.selectedPoint = Math.min(a, b);
        state.selectedPointEnd = Math.max(a, b);
        draw();
        updateStrokeList();
        return;
      }
      // If clicking a point that's in the multi-selection, start multi-drag
      if (state.selectedMulti.length > 0 &&
          state.selectedMulti.some(m => m.stroke === hit.stroke && m.point === hit.point)) {
        pushUndo();
        multiDragging = true;
        dragging = true;
        dragStartX = mx;
        dragStartY = my;
        return;
      }
      pushUndo();
      state.selectedStroke = hit.stroke;
      state.selectedPoint = hit.point;
      state.selectedPointEnd = -1;
      state.selectedMulti = [];
      multiDragging = false;
      dragging = true;
      dragStartX = mx;
      dragStartY = my;
      draw();
      updateStrokeList();
      return;
    }

    const seg = findNearestSegment(mx, my);
    if (seg) {
      pushUndo();
      const coordX = mx / SCALE;
      const coordY = my / SCALE;
      state.strokes[seg.stroke].splice(seg.after + 1, 0, [coordX, coordY]);
      state.selectedStroke = seg.stroke;
      state.selectedPoint = seg.after + 1;
      state.selectedPointEnd = -1;
      state.selectedMulti = [];
      state.dirty = true;
      dragging = true;
      draw();
      updateStrokeList();
      return;
    }

    // Start marquee selection on empty space
    state.selectedStroke = -1;
    state.selectedPoint = -1;
    state.selectedPointEnd = -1;
    state.selectedMulti = [];
    marquee = {x1: mx, y1: my, x2: mx, y2: my};
    dragging = true;
    draw();
    updateStrokeList();

  } else if (state.mode === 'addStroke') {
    const coordX = mx / SCALE;
    const coordY = my / SCALE;
    state.newStrokePoints.push([coordX, coordY]);
    draw();

  } else if (state.mode === 'deleteStroke') {
    const hit = findPoint(mx, my, 15);
    if (hit) {
      deleteStroke(hit.stroke);
      setMode('select');
      return;
    }
    const seg = findNearestSegment(mx, my, 15);
    if (seg) {
      deleteStroke(seg.stroke);
      setMode('select');
    }

  } else if (state.mode === 'joinStroke') {
    const hit = findPoint(mx, my);
    if (!hit) return;

    if (!state.joinFirst) {
      // First click: remember the point
      state.joinFirst = {stroke: hit.stroke, point: hit.point};
      state.selectedStroke = hit.stroke;
      state.selectedPoint = hit.point;
      state.selectedPointEnd = -1;
      draw();
      updateStrokeList();
      setStatus('Now click a point on the second stroke');
    } else {
      // Second click: join
      if (hit.stroke === state.joinFirst.stroke) {
        setStatus('Must pick a point on a different stroke');
        return;
      }
      joinStrokes(state.joinFirst, hit);
    }

  } else if (state.mode === 'addVertex' || state.mode === 'addTermination') {
    const coordX = mx / SCALE;
    const coordY = my / SCALE;
    const markerType = state.mode === 'addVertex' ? 'vertex' : 'termination';
    // Check if clicking near an existing marker of same type to remove it
    const HIT_DIST = 10;
    let removed = false;
    for (let i = state.markers.length - 1; i >= 0; i--) {
      const m = state.markers[i];
      const d = Math.sqrt((m.x - coordX) ** 2 + (m.y - coordY) ** 2);
      if (d < HIT_DIST && m.type === markerType) {
        state.markers.splice(i, 1);
        removed = true;
        break;
      }
    }
    if (!removed) {
      state.markers.push({x: coordX, y: coordY, type: markerType});
    }
    state.dirty = true;
    draw();
    const vc = state.markers.filter(m => m.type === 'vertex').length;
    const tc = state.markers.filter(m => m.type === 'termination').length;
    setStatus(`${markerType === 'vertex' ? (removed ? 'Removed' : 'Added') : (removed ? 'Removed' : 'Added')} ${markerType} (${vc}V, ${tc}T)`);
  }
});

canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (CANVAS_SIZE / rect.width);
  const my = (e.clientY - rect.top) * (CANVAS_SIZE / rect.height);

  if (marquee) {
    marquee.x2 = mx;
    marquee.y2 = my;
    draw();
    return;
  }

  if (multiDragging && state.selectedMulti.length > 0) {
    const dx = (mx - dragStartX) / SCALE;
    const dy = (my - dragStartY) / SCALE;
    for (const m of state.selectedMulti) {
      const p = state.strokes[m.stroke][m.point];
      p[0] = Math.max(0, Math.min(COORD_SIZE, p[0] + dx));
      p[1] = Math.max(0, Math.min(COORD_SIZE, p[1] + dy));
    }
    dragStartX = mx;
    dragStartY = my;
    state.dirty = true;
    draw();
    return;
  }

  if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
    const coordX = Math.max(0, Math.min(COORD_SIZE, mx / SCALE));
    const coordY = Math.max(0, Math.min(COORD_SIZE, my / SCALE));
    state.strokes[state.selectedStroke][state.selectedPoint] = [coordX, coordY];
    state.dirty = true;
    draw();
  }
});

canvas.addEventListener('mouseup', () => {
  if (marquee) {
    // Normalize rectangle bounds
    const left = Math.min(marquee.x1, marquee.x2) / SCALE;
    const right = Math.max(marquee.x1, marquee.x2) / SCALE;
    const top = Math.min(marquee.y1, marquee.y2) / SCALE;
    const bottom = Math.max(marquee.y1, marquee.y2) / SCALE;

    // Only select if dragged a meaningful distance (> 5 canvas pixels)
    const w = Math.abs(marquee.x2 - marquee.x1);
    const h = Math.abs(marquee.y2 - marquee.y1);
    if (w > 5 || h > 5) {
      // Find all points inside the rectangle
      const multi = [];
      for (let si = 0; si < state.strokes.length; si++) {
        for (let pi = 0; pi < state.strokes[si].length; pi++) {
          const px = state.strokes[si][pi][0];
          const py = state.strokes[si][pi][1];
          if (px >= left && px <= right && py >= top && py <= bottom) {
            multi.push({stroke: si, point: pi});
          }
        }
      }
      state.selectedMulti = multi;
      state.selectedStroke = -1;
      state.selectedPoint = -1;
      state.selectedPointEnd = -1;
      if (multi.length > 0) {
        setStatus(`${multi.length} points selected`);
      }
    }
    marquee = null;
    draw();
    updateStrokeList();
  }
  dragging = false;
  multiDragging = false;
});
canvas.addEventListener('mouseleave', () => {
  if (marquee) {
    marquee = null;
    draw();
  }
  dragging = false;
  multiDragging = false;
});

// --- Keyboard handlers ---

document.addEventListener('keydown', e => {
  // Ignore hotkeys when a modifier is held (except specific combos)
  const hasModifier = e.ctrlKey || e.metaKey || e.altKey;

  // Ctrl/Cmd combos
  if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    save();
    return;
  }
  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    undo();
    return;
  }

  // Don't process single-key hotkeys if modifier held
  if (hasModifier) return;

  switch (e.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
        e.preventDefault();
        const s1 = state.strokes[state.selectedStroke];
        if (state.selectedPoint < s1.length - 1) {
          state.selectedPoint++;
          state.selectedPointEnd = -1;
          draw();
          updateStrokeList();
        }
      }
      break;

    case 'ArrowLeft':
    case 'ArrowUp':
      if (state.selectedStroke >= 0 && state.selectedPoint >= 0) {
        e.preventDefault();
        if (state.selectedPoint > 0) {
          state.selectedPoint--;
          state.selectedPointEnd = -1;
          draw();
          updateStrokeList();
        }
      }
      break;

    case 'Delete':
    case 'Backspace':
      if (state.selectedMulti.length > 0 || (state.selectedStroke >= 0 && state.selectedPoint >= 0)) {
        e.preventDefault();
        deleteSelectedPoint();
      }
      break;

    case 'Escape':
      if (state.mode === 'addStroke') {
        state.newStrokePoints = [];
        setMode('select');
      } else {
        state.selectedStroke = -1;
        state.selectedPoint = -1;
        state.selectedPointEnd = -1;
        state.selectedMulti = [];
        draw();
        updateStrokeList();
      }
      break;

    case 'Enter':
      if (state.mode === 'addStroke') {
        if (state.newStrokePoints.length >= 1) {
          pushUndo();
          if (state.newStrokePoints.length === 1) {
            const p = state.newStrokePoints[0];
            state.newStrokePoints.push([p[0], p[1]]);
          }
          state.strokes.push(state.newStrokePoints);
          state.dirty = true;
          updateStrokeList();
        }
        state.newStrokePoints = [];
        setMode('select');
      }
      break;

    case 'v': setMode('select'); break;
    case 'a': setMode('addStroke'); break;
    case 'x': setMode('deleteStroke'); break;
    case 'b': splitStroke(); break;
    case 't': toggleVertex(); break;
    case 'j': startJoin(); break;
    case 'n': runSnap(); break;
    case 'm': runCenterBorders(); break;
    case 'o': runCenter(); break;
    case 'd': runDedup(); break;
    case 'c': runConnect(); break;
    case 'g': runSmooth(); break;
    case 'e': runResample(); break;
    case 'k': runSkeleton(); break;
    case 'f': runSkeletonFull(); break;
    case 'w': runAutoJoin(); break;
    case 'q': runReduce(); break;
    case '1': setMode('addVertex'); break;
    case '2': setMode('addTermination'); break;
    case '3': clearMarkers(); break;
    case '4': detectMarkers(); break;
    case 'r': reloadChar(); break;
    case '=':
    case '+': runScale(1.03); break;
    case '-': runScale(1/1.03); break;
    case '[': navigateChar(-1); break;
    case ']': navigateChar(1); break;
  }
});

// --- Navigation ---

function navigateChar(dir) {
  const idx = CHAR_LIST.indexOf(CHAR);
  if (idx < 0) return;
  const next = idx + dir;
  if (next < 0 || next >= CHAR_LIST.length) return;
  if (state.dirty && !confirm('Unsaved changes. Continue?')) return;
  window.location.href = `/edit/${FONT_ID}?c=${encodeURIComponent(CHAR_LIST[next])}`;
}

// --- Init ---
load();
</script>
</body>
</html>
